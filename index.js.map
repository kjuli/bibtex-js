{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 3bc543455d669765ba50","webpack:///./src/util.ts","webpack:///./src/bibfile/datatype/string/QuotedString.ts","webpack:///./src/bibfile/datatype/string/BracedString.ts","webpack:///./src/bibfile/datatype/string/bib-string-utils.ts","webpack:///./src/bibfile/datatype/string/BibStringComponent.ts","webpack:///./src/bibfile/datatype/string/StringRef.ts","webpack:///./src/bibfile/datatype/KeyVal.ts","webpack:///./src/bibfile/bib-entry/BibStringEntry.ts","webpack:///./src/bibfile/bib-entry/bibliographic-entity/Author.ts","webpack:///./src/bibfile/bib-entry/bibliographic-entity/Authors.ts","webpack:///./src/bibfile/bib-entry/BibComment.ts","webpack:///./src/bibfile/bib-entry/BibEntry.ts","webpack:///./src/bibfile/bib-entry/BibPreamble.ts","webpack:///./src/bibfile/BibFile.ts","webpack:///./src/lexer/Token.ts","webpack:///./src/lexer/WhitespaceToken.ts","webpack:///./src/lexer/NumericToken.ts","webpack:///./src/index.ts","webpack:///./src/bibfile/bib-entry/bibliographic-entity/mandatory-and-optional-fields.ts","webpack:///./node_modules/nearley/lib/nearley.js","webpack:///./src/parser/ts-parser.ts","webpack:///./src/lexer/Lexer.ts","webpack:///./src/lexer/IdToken.ts","webpack:///./src/lexer/BibBlockTypes.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","mustBeString","str","Error","JSON","stringify","mustBeDefined","t","undefined","mustBeArray","isArray","data","constructor","Array","isNumber","isString","value","flattenMyArray","arr","result","length","i_1","length_1","value2","push","isOuterQuotedString","x","type","isQuotedString","__extends","extendStatics","b","setPrototypeOf","__proto__","__","TypeError","String","create","OuterQuotedString","QuotedString","BibStringComponent_1","_super","braceDepth","BibStringComponent","BibOuterStringComponent","isOuterBracedString","isBracedString","OuterBracedString","BracedString","_this","isSpecialCharacter","isBibStringComponent","isContiguousSimpleString","util_1","joinContiguousSimpleStrings","join","parseStringComponent","obj","StringRef_1","isStringRef","StringRef","stringref","string","BracedString_1","map","e","flattened","QuotedString_1","toStringBibStringDatum","toStringBibStringData","flattenQuotedStrings","hideQuotes","_i","data_1","datum","flattenned","flattenQuotedString","concat","flattenedQuotedString","doubleQuotes","globContiguousStrings","data_2","element","contiguousSimpleString","lastElement","splitOnAnd","splitOnPattern","splitOnComma","limit","pattern","stopAfter","splitted","buffer","data_3","match","exec","end","prevEnd","index","substring","stringifyDatum","toString","isKeyVal","key","newKeyVal","parseFieldValue","bib_string_utils_1","normalizeFieldValue","field","newStringEntry","_a","convertToKeyVal","BibStringEntry","KeyVal_1","resolveStrings","strings","resolved","keys","forEach","resolveStringReference","resolveStringReferences","seenBeforeStack","alreadyResolved","refs","resolveStringRef","copyWithResolvedStringReferences","copyOuterWithResolvedStringReferences","refName","assign","newData","copied","getFirstLetter","bsd","asString","charAt","startsWithLowerCaseBSD","authorToken","startsWithLowerCase","ch","toLowerCase","toUpperCase","firstVonLast","outer","authorTokens","WHITESPACES","vonStartInclusive","vonEndExclusive","firstNameEndExclusive","von","getSubStringAsArray","firstName","lastName","Math","max","AuthorName","vonLastFirst","vonLastStr","firstStr","vonLast","first","tokens","startIncl","endExcl","vonLastJrFirst","jrStr","jr","parseAuthorName","normalizedFieldValue","partitions","mdbsd","isdbsd","firstNames","vons","lastNames","jrs","firstNames$","vons$","lastNames$","jrs$","initials","id","parseAuthor","Author_1","determineAuthorNames$","determineAuthorNames","globbed","normalizedString","mustBeAuthors","isAuthors","Authors","fieldValue","authorNames","authors$","isBibComment","flattenPlainText","flattenO","CommentEntry","BibComment","wrapper","parseEntryFields","fields","fieldz","isBibEntry","processEntry","entry","strings$","processedFields","fields$","field$","BibStringEntry_1","Authors_1","BibEntry","_id","sortkey$","title$","getField","getFieldAsString","getAuthors","isPreamble","newPreambleNode","BibFile_1","parseBibEntriesAndNonEntries","Preamble","parseNonEntry","nonEntry","BibComment_1","parseEntry","BibEntry_1","BibPreamble_1","parseBibFile","input","nearley","Parser","ts_parser_1","grammar","ParserRules","ParserStart","feed","Lexer_1","default","readTokens","res","results","parse","BibFilePresenter","content","comments","filter","preambles_raw","preamble$","strings_raw","entries_raw","entryMap","entries$","getEntry","entity","newToken","isSpecialChar","specialChars","isEscapableChar","escapableChars","@","(",")","{","}","#","=",",","\\","\"","newWhitespace","isWhitespace","token","WS","isSingleWhiteSpaceCharacter","singleWhitespaces"," ","\t","\r","\n","newNumber","isNum","numericChars","0","1","2","3","4","5","6","7","8","9","__createBinding","k","k2","__exportStar","hasOptionalFields","optionalFields","hasMandatoryFields","mandatoryFields","getMandatoryFields","getOptionalFields","findError","year","volume","title","series","school","publisher","pages","organization","number","note","month","journal","institution","howpublished","editor","edition","chapter","booktitle","author","address","book","booklet","conference","inproceedings","inbook","incollection","manual","mastersthesis","misc","phdthesis","proceedings","techreport","unpublished","article","hasAllFields","reduce","acc","fieldName","Rule","symbols","postprocess","highestId","State","rule","dot","reference","wantedBy","isComplete","Column","states","wants","scannable","completed","Grammar","rules","start","byName","StreamLexer","reset","options","fromCompiled","keepHistory","lexer","lexerState","column","table","predict","process","current","withCursorAt","stringifySymbolSequence","literal","symbolSequence","slice","nextState","child","state","left","right","build","children","node","reverse","finish","fail","nextColumn","w","complete","exp","nulls","r","inp","copy","Lexer","g","line","lastLineBreak","col","next","save","formatError","message","nextLineBreak","indexOf","chunk","expect","test","isToken","err","offset","restore","splice","rewind","considerations","addToObj","keyval","joinTokens","strs","Number","tok_id","entry_type_bib","entry_type_string","entry_type_preamble","entry_type_comment","ws","num","pound","eq","esc","paren_l","paren_r","brace_l","brace_r","quote_dbl","comma","topLevelObjects","toeknz","tk","keyvals","kv","tkz","tks","tokenz","Ti","Token_1","WhitespaceToken_1","NumericToken_1","IdToken_1","BibBlockTypes_1","len","pos","getStringUntilNonEscapedChar","terminalRegex","chars","nextToken","readNextToken","currentChar","eatWhiteSpace","eatSpecialChars","eatNumericString","eatIdString","pos2","charAtI","isIdChar","newIdToken","trim","startAt","nums","nextPos","newPos","newChar","numericString","parseInt","isFinite","isBibType","bibTypes","isIdToken","preamble","comment","bib"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,QACA,sBAAAG,gBAAAC,IACAD,UAAAH,OACA,CACA,GAAAK,GAAAL,GACA,QAAAM,KAAAD,IAAA,gBAAAJ,iBAAAF,GAAAO,GAAAD,EAAAC,KAECC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAJ,EAAAI,EACAE,GAAA,EACAX,WAUA,OANAO,GAAAE,GAAAG,KAAAX,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAU,GAAA,EAGAV,EAAAD,QAvBA,GAAAU,KA4DA,OAhCAF,GAAAK,EAAAN,EAGAC,EAAAM,EAAAJ,EAGAF,EAAAO,EAAA,SAAAf,EAAAgB,EAAAC,GACAT,EAAAU,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAT,EAAAgB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAO,GAAAO,EAAAE,EAAA,IAAAA,GACAA,GAIAT,EAAAU,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDnB,EAAAsB,EAAA,GAGAtB,IAAAuB,EAAA,MDgBM,SAAU9B,EAAQD,EAASQ,GAEjC,YE3EA,SAAgBwB,GAAaC,EAAUf,GACnC,GAAmB,gBAARe,GACP,KAAM,IAAIC,OAAM,0BAA4BC,KAAKC,UAAUlB,GAAQe,GACvE,OAAOA,GAGX,QAAgBI,GAAiBC,EAAOpB,GACpC,OAAUqB,KAAND,EACA,KAAM,IAAIJ,OAAM,2BAA6BC,KAAKC,UAAUlB,GAAQoB,GACxE,OAAOA,GAGX,QAAgBE,GAAYP,EAAUf,GAClC,IAAKuB,EAAQR,GACT,KAAM,IAAIC,OAAM,yBAA2BC,KAAKC,UAAUlB,GAAQe,GACtE,OAAOA,GAGX,QAAgBQ,GAAQC,GACpB,QAASA,GAAQA,EAAKC,cAAgBC,MAG1C,QAAgBC,GAASH,GACrB,MAAuB,gBAATA,GAIlB,QAAgBI,GAASJ,GACrB,MAAuB,gBAATA,GFiDlBvB,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQgD,eAAiBhD,EAAQ8C,SAAW9C,EAAQ6C,SAAW7C,EAAQyC,QAAUzC,EAAQwC,YAAcxC,EAAQqC,cAAgBrC,EAAQgC,iBAAe,GE9EtJhC,EAAAgC,eAMAhC,EAAAqC,gBAMArC,EAAAwC,cAMAxC,EAAAyC,UAIAzC,EAAA6C,WAKA7C,EAAA8C,UAIO,IAAME,GAAiB,SAAUC,EAAYC,GAC3CA,IAAQA,KACb,KAAK,GAAI7C,GAAI,EAAG8C,EAASF,EAAIE,OAAQ9C,EAAI8C,EAAQ9C,IAAK,CAClD,GAAM0C,GAAaE,EAAI5C,EACvB,IAAIuC,MAAMH,QAAQM,GACd,IAAK,GAAIK,GAAI,EAAGC,EAASN,EAAMI,OAAQC,EAAIC,EAAQD,IAAK,CACpD,GAAME,GAAcP,EAAMK,EACtBR,OAAMH,QAAQa,IACd,EAAAtD,EAAAgD,gBAAeM,EAAQJ,GAEvBA,EAAOK,KAAKD,OAIpBJ,GAAOK,KAAKR,GAGpB,MAAOG,GAjBElD,GAAAgD,eAAcA,GFyGrB,SAAU/C,EAAQD,EAASQ,GAEjC,YGxHA,SAAgBgD,GAAoBC,GAChC,MAAkB,wBAAXA,EAAEC,KAGb,QAAgBC,GAAeF,GAC3B,MAAkB,iBAAXA,EAAEC,KHqHb,GAAIE,GAAatD,MAAQA,KAAKsD,WAAc,WACxC,GAAIC,GAAgB,SAAU9C,EAAG+C,GAI7B,OAHAD,EAAgB1C,OAAO4C,iBAChBC,uBAA2BpB,QAAS,SAAU7B,EAAG+C,GAAK/C,EAAEiD,UAAYF,IACvE,SAAU/C,EAAG+C,GAAK,IAAK,GAAIhC,KAAKgC,GAAO3C,OAAOS,UAAUC,eAAejB,KAAKkD,EAAGhC,KAAIf,EAAEe,GAAKgC,EAAEhC,MAC3Ef,EAAG+C,GAE5B,OAAO,UAAU/C,EAAG+C,GAIhB,QAASG,KAAO3D,KAAKqC,YAAc5B,EAHnC,GAAiB,kBAAN+C,IAA0B,OAANA,EAC3B,KAAM,IAAII,WAAU,uBAAyBC,OAAOL,GAAK,gCAC7DD,GAAc9C,EAAG+C,GAEjB/C,EAAEa,UAAkB,OAANkC,EAAa3C,OAAOiD,OAAON,IAAMG,EAAGrC,UAAYkC,EAAElC,UAAW,GAAIqC,OAGvF9C,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ2D,eAAiB3D,EAAQwD,oBAAsBxD,EAAQqE,kBAAoBrE,EAAQsE,iBAAe,EGhK1G,IAAAC,GAAA/D,EAAA,GAUA8D,EAAA,SAAAE,GACI,QAAAF,GAAYG,EAAoB/B,GH0J5B,MGzJA8B,GAAA5D,KAAAN,KAAM,eAAgBmE,EAAY/B,IAAKpC,KAE/C,MAJkCsD,GAAAU,EAAAE,GAIlCF,GAJkCC,EAAAG,mBAArB1E,GAAAsE,cAMb,IAAAD,GAAA,SAAAG,GACI,QAAAH,GAAY3B,GH4JR,MG3JA8B,GAAA5D,KAAAN,KAAM,sBAAuBoC,IAAKpC,KAE1C,MAJuCsD,GAAAS,EAAAG,GAIvCH,GAJuCE,EAAAI,wBAA1B3E,GAAAqE,oBAMbrE,EAAAwD,sBAIAxD,EAAA2D,kBHoKM,SAAU1D,EAAQD,EAASQ,GAEjC,YI/JA,SAAgBoE,GAAoBnB,GAChC,MAAkB,wBAAXA,EAAEC,KAGb,QAAgBmB,GAAepB,GAC3B,MAAkB,iBAAXA,EAAEC,KJ4Jb,GAAIE,GAAatD,MAAQA,KAAKsD,WAAc,WACxC,GAAIC,GAAgB,SAAU9C,EAAG+C,GAI7B,OAHAD,EAAgB1C,OAAO4C,iBAChBC,uBAA2BpB,QAAS,SAAU7B,EAAG+C,GAAK/C,EAAEiD,UAAYF,IACvE,SAAU/C,EAAG+C,GAAK,IAAK,GAAIhC,KAAKgC,GAAO3C,OAAOS,UAAUC,eAAejB,KAAKkD,EAAGhC,KAAIf,EAAEe,GAAKgC,EAAEhC,MAC3Ef,EAAG+C,GAE5B,OAAO,UAAU/C,EAAG+C,GAIhB,QAASG,KAAO3D,KAAKqC,YAAc5B,EAHnC,GAAiB,kBAAN+C,IAA0B,OAANA,EAC3B,KAAM,IAAII,WAAU,uBAAyBC,OAAOL,GAAK,gCAC7DD,GAAc9C,EAAG+C,GAEjB/C,EAAEa,UAAkB,OAANkC,EAAa3C,OAAOiD,OAAON,IAAMG,EAAGrC,UAAYkC,EAAElC,UAAW,GAAIqC,OAGvF9C,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ6E,eAAiB7E,EAAQ4E,oBAAsB5E,EAAQ8E,kBAAoB9E,EAAQ+E,iBAAe,EIjN1G,IAAAR,GAAA/D,EAAA,GAMAuE,EAAA,SAAAP,GAWI,QAAAO,GAAYN,EAAoB/B,GAAhC,GAAAsC,GACIR,EAAA5D,KAAAN,KAAM,eAAgBmE,EAAY/B,IAAKpC,IJsMvC,OInMA0E,GAAKC,mBAAoC,IAAfR,GAAgC,OAAZ/B,EAAK,GJmM5CsC,EIhMf,MAlBkCpB,GAAAmB,EAAAP,GAkBlCO,GAlBkCR,EAAAG,mBAArB1E,GAAA+E,cAoBb,IAAAD,GAAA,SAAAN,GACI,QAAAM,GAAYpC,GJqMR,MIpMA8B,GAAA5D,KAAAN,KAAM,sBAAuBoC,IAAKpC,KAE1C,MAJuCsD,GAAAkB,EAAAN,GAIvCM,GAJuCP,EAAAI,wBAA1B3E,GAAA8E,oBAMb9E,EAAA4E,sBAIA5E,EAAA6E,kBJ6MM,SAAU5E,EAAQD,EAASQ,GAEjC,YK7OA,SAAgB0E,GAAqBzB,GACjC,MAA+B,gBAAjBA,GAAEgB,YAA6C,gBAAXhB,GAAEC,KAQxD,QAAgByB,GAAyB1B,GACrC,MAAkB,2BAAXA,EAAEC,OAAqC,EAAA0B,EAAA3C,SAAQgB,EAAEf,MAG5D,QAAgB2C,GAA4B5B,GACxC,MAAOA,GAAEf,KAAK4C,KAAK,IAIvB,QAAgBC,GAAqBd,EAAoBe,GACrD,IAAI,EAAAJ,EAAAvC,UAAS2C,KAAQ,EAAAJ,EAAAtC,UAAS0C,GAC1B,MAA2DA,EAE/D,KAAI,EAAAC,EAAAC,aAAYF,GACZ,MAAO,IAAIC,GAAAE,UAAU,EAAGH,EAAII,UAIhC,SAAQ,EAAAR,EAAApD,cAAawD,EAAI9B,KAAM8B,IAC3B,IAAK,KACL,IAAK,KACL,IAAK,SACD,OAAO,EAAAJ,EAAApD,cAAawD,EAAIK,OAC5B,KAAK,eACL,IAAK,SACD,KAAK,EAAAT,EAAA3C,SAAQ+C,EAAI9C,MACb,KAAM,IAAIR,OAAM,0BAA4BC,KAAKC,UAAUoD,GAE/D,OAAO,IAAIM,GAAAf,aAAaN,GAAY,EAAAW,EAAApC,gBAAewC,EAAI9C,MAAMqD,IAAI,SAAAC,GAAK,MAAAT,GAAqBd,EAAa,EAAGuB,KAC/G,KAAK,eACD,KAAK,EAAAZ,EAAA3C,SAAQ+C,EAAI9C,MACb,KAAM,IAAIR,OAAM,0BAA4BC,KAAKC,UAAUoD,GAE/D,IAAMS,IAAY,EAAAb,EAAApC,gBAAewC,EAAI9C,KACrC,OAAO,IAAIwD,GAAA5B,aAAaG,EAAYwB,EAAUF,IAAI,SAAAC,GAAK,MAAAT,GAAqBd,EAAYuB,KAC5F,SACI,KAAM,IAAI9D,OAAM,mCAAqCsD,EAAI9B,OAIrE,QAAgByC,GAAuBzD,GACnC,IAAI,EAAA0C,EAAAtC,UAASJ,GACT,MAAOA,EACX,KAAI,EAAA0C,EAAAvC,UAASH,GACT,MAAOA,GAAO,EAClB,KACI,EAAAoD,EAAAjB,gBAAenC,KACZ,EAAAwD,EAAAvC,gBAAejB,KACf,EAAAwD,EAAA1C,qBAAoBd,KACpB,EAAAoD,EAAAlB,qBAAoBlC,GAEvB,MAAO0D,GAAsB1D,EAAKA,KAEtC,MAAM,IAAIR,OAAMC,KAAKC,UAAUM,IAGnC,QAAgB0D,GAAsB1D,GAClC,MAAOA,GAAKqD,IAAII,GAAwBb,KAAK,IAGjD,QAAgBe,GAAqB3D,EAAqB4D,GAEtD,IAAoB,GADhBpD,MACgBqD,EAAA,EAAAC,EAAA9D,EAAA6D,EAAAC,EAAArD,OAAAoD,IAAM,CAArB,GAAME,GAAKD,EAAAD,GACNG,EAAaC,EAAoBF,EAAOH,IAC1C,EAAAlB,EAAA3C,SAAQiE,GACRxD,EAASA,EAAO0D,OAAOF,GAEvBxD,EAAOK,KAAKmD,GAGpB,MAAOxD,GAKX,QAASyD,GAAoBjE,EAAsB4D,GAC/C,IAAI,EAAAR,EAAAjB,gBAAenC,GACf,MAAOA,EACX,KAAI,EAAAwD,EAAAvC,gBAAejB,GAAO,CACtB,GAAMmE,GAAuCR,EAAqB3D,EAAKA,MAAM,EAC7E,QAAI,EAAA0C,EAAA3C,SAAQoE,GACDP,EACDO,EACAC,EAAaF,OAAOC,GAAuBD,OAAOE,GACjDR,EACAO,GAEC,IAAMA,EAAuB,KAE7C,IAAI,EAAAX,EAAA1C,qBAAoBd,GACpB,MAAO2D,GAAqB3D,EAAKA,MAAM,EAC3C,KAAI,EAAAoD,EAAAlB,qBAAoBlC,GACpB,MAAO2D,GAAqB3D,EAAKA,MAAM,EAC3C,KAAI,EAAA0C,EAAAtC,UAASJ,KAAS,EAAA0C,EAAAvC,UAASH,GAC3B,MAAOA,EACX,OAAI,EAAA+C,EAAAC,aAAYhD,GACN,GAAIR,OAAM,+CAEV,GAAIA,OAGlB,QAAgB6E,GAAsBrE,GAElC,IAAsB,GADhBQ,MACgBqD,EAAA,EAAAS,EAAAtE,EAAA6D,EAAAS,EAAA7D,OAAAoD,IAAM,CAAvB,GAAMU,GAAOD,EAAAT,EACd,KAAI,EAAAnB,EAAAtC,UAASmE,KAAY,EAAA7B,EAAAvC,UAASoE,GAC9B,GAAI/D,EAAOC,QAAU,EAAG,CACpB,GAAM+D,IACFxD,KAAM,yBACNhB,MAAOuE,GAEX/D,GAAOK,KAAK2D,OAEX,CACD,GAAMC,GAAcjE,EAAOA,EAAOC,OAAS,EAC3C,IAAIgC,EAAyBgC,GACzBA,EAAYzE,KAAKa,KAAK0D,OACnB,CACH,GAAMC,IACFxD,KAAM,yBACNhB,MAAOuE,GAEX/D,GAAOK,KAAK2D,QAIpBhE,GAAOK,KAAK0D,GAGpB,MAAO/D,GAGX,QAAgBkE,GAAW1E,GACvB,MAAO2E,GAAe3E,EAAM,cAGhC,QAAgB4E,GAAa5E,EAAqB6E,GAC9C,WAD8C,KAAAA,MAAA,GACvCF,EAAe3E,EAAM,WAAY6E,GAG5C,QAAgBF,GAAe3E,EAAqB8E,EAAiBC,GAIjE,IAAoB,GAHdC,MAEFC,KACgBpB,EAAA,EAAAqB,EAAAlF,EAAA6D,EAAAqB,EAAAzE,OAAAoD,IAAM,CAArB,GAAME,GAAKmB,EAAArB,EACZ,KAAI,EAAAnB,EAAAtC,UAAS2D,SAAyBlE,KAAdkF,GAA2BA,EAAY,GAAI,CAC/D,GAAII,GAA4CL,EAAQM,KAAKrB,GACzDsB,EAAM,CACV,IAAIF,EAAO,CACP,EAAG,CACC,GAAMG,GAAUD,CAChBA,GAAMF,EAAMI,MAAQJ,EAAM,GAAG1E,OAE7BwE,EAAOpE,KAAKkD,EAAMyB,UAAUF,EAASH,EAAMI,aAEzB1F,KAAdkF,GAA2BA,EAAY,KACvCC,EAASnE,KAAKoE,GACdA,SACkBpF,KAAdkF,GAA2BA,EAAY,GAAGA,KAI9CI,MADctF,KAAdkF,GAA2BA,EAAY,EAC/BD,EAAQM,KAAKrB,OAEblE,SACPsF,EAELE,GAAM,GAAKA,EAAMtB,EAAMtD,QACvBwE,EAAOpE,KAAKkD,EAAMyB,UAAUH,QAEhCJ,GAAOpE,KAAKkD,OAIhBkB,GAAOpE,KAAKkD,GAIpB,MADIkB,GAAOxE,OAAS,GAAGuE,EAASnE,KAAKoE,GAC9BD,ELqDXvG,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQqH,eAAiBrH,EAAQsH,aAAetH,EAAQoH,WAAapH,EAAQ+G,sBAAwB/G,EAAQqG,qBAAuBrG,EAAQoG,sBAAwBpG,EAAQmG,uBAAyBnG,EAAQuF,qBAAuBvF,EAAQqF,4BAA8BrF,EAAQmF,yBAA2BnF,EAAQkF,yBAAuB,EKvP5U,IAAAO,GAAAjF,EAAA,GACAsF,EAAAtF,EAAA,GACA0F,EAAA1F,EAAA,GACA4E,EAAA5E,EAAA,EAIAR,GAAAkF,uBASAlF,EAAAmF,2BAIAnF,EAAAqF,8BAKArF,EAAAuF,uBA+BAvF,EAAAmG,yBAgBAnG,EAAAoG,wBAIApG,EAAAqG,sBAaA,IAAMS,IAAkC,IA4BxC9G,GAAA+G,wBA8BA/G,EAAAoH,aAIApH,EAAAsH,eAIAtH,EAAAqH,kBLwRM,SAAUpH,EAAQD,EAASQ,GAEjC,YMzZA,SAAS0E,GAAqBzB,GAC1B,MAA+B,gBAAjBA,GAAEgB,YAA6C,gBAAXhB,GAAEC,KAGxD,QAAgByE,GAAe1B,GAC3B,IAAI,EAAArB,EAAAtC,UAAS2D,GAAQ,MAAOA,EAC5B,KAAI,EAAArB,EAAAvC,UAAS4D,GAAQ,MAAOA,GAAM2B,UAClC,IAAIlD,EAAqBuB,GAAQ,MAAOA,GAAMrE,WAEzC,MAAM,IAAIF,OAAM,oBNkZzB,GAAI0B,GAAatD,MAAQA,KAAKsD,WAAc,WACxC,GAAIC,GAAgB,SAAU9C,EAAG+C,GAI7B,OAHAD,EAAgB1C,OAAO4C,iBAChBC,uBAA2BpB,QAAS,SAAU7B,EAAG+C,GAAK/C,EAAEiD,UAAYF,IACvE,SAAU/C,EAAG+C,GAAK,IAAK,GAAIhC,KAAKgC,GAAO3C,OAAOS,UAAUC,eAAejB,KAAKkD,EAAGhC,KAAIf,EAAEe,GAAKgC,EAAEhC,MAC3Ef,EAAG+C,GAE5B,OAAO,UAAU/C,EAAG+C,GAIhB,QAASG,KAAO3D,KAAKqC,YAAc5B,EAHnC,GAAiB,kBAAN+C,IAA0B,OAANA,EAC3B,KAAM,IAAII,WAAU,uBAAyBC,OAAOL,GAAK,gCAC7DD,GAAc9C,EAAG+C,GAEjB/C,EAAEa,UAAkB,OAANkC,EAAa3C,OAAOiD,OAAON,IAAMG,EAAGrC,UAAYkC,EAAElC,UAAW,GAAIqC,OAGvF9C,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ2E,wBAA0B3E,EAAQmI,eAAiBnI,EAAQ0E,uBAAqB,EMtcxF,IAAAU,GAAA5E,EAAA,GAMAkE,EAAA,WASI,QAAAA,GAAYhB,EAAce,EAAoB/B,GAC1CpC,KAAKoD,KAAOA,EACZpD,KAAKmE,WAAaA,EAClBnE,KAAKoC,KAAOA,EAOpB,MAHIgC,GAAA9C,UAAAQ,UAAA,WACI,MAAO9B,MAAKoC,KAAKqD,IAAIoC,GAAgB7C,KAAK,KAElDZ,IAnBa1E,GAAA0E,qBAyBb1E,EAAAmI,gBAQA,IAAAxD,GAAA,SAAAH,GACI,QAAAG,GAAYjB,EAAchB,GN6btB,MM5bA8B,GAAA5D,KAAAN,KAAMoD,EAAM,EAAGhB,IAAKpC,KAE5B,MAJ6CsD,GAAAe,EAAAH,GAI7CG,GAJ6CD,EAAhC1E,GAAA2E,2BNucP,SAAU1E,EAAQD,EAASQ,GAEjC,YOpeA,SAAgBkF,GAAYE,GACxB,MAAsC,gBAAxBA,GAAUA,UPqe5BzE,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ0F,YAAc1F,EAAQ2F,cAAY,EOjf1C,IAAAA,GAAA,WAII,QAAAA,GAAYlB,EAAoBmB,GAC5BtF,KAAKmE,WAAaA,EAClBnE,KAAKsF,UAAYA,EAEzB,MAAAD,KARa3F,GAAA2F,YAUb3F,EAAA0F,ePwfM,SAAUzF,EAAQD,EAASQ,GAEjC,YQzfA,SAAgB6H,GAAS3F,GACrB,MAA2B,gBAAbA,GAAK4F,SACG/F,KAAfG,EAAKK,MAGhB,QAAgBwF,GAAU7F,GACtB,GAAI2F,EAAS3F,GACT,OACI4F,IAAK5F,EAAK4F,IACVvF,MAAOyF,EAAgB9F,EAAKK,OAGhC,MAAM,IAAIb,OAAM,qBAAuBC,KAAKC,UAAUM,IAI9D,QAAgB8F,GAAgBzF,GAC5B,IAAI,EAAAqC,EAAAvC,UAASE,GACT,MAAOA,EAGX,IAAML,IAAO,EAAA0C,EAAA5C,aAAYO,EAAML,KAC/B,QAAQK,EAAMW,MACV,IAAK,sBACD,MAAoB,KAAhBhB,EAAKS,SAAgB,EAAAiC,EAAAvC,UAASH,EAAK,IAI5BA,EAAK,GAET,GAAIwD,GAAA7B,kBAAkB3B,EAAKqD,IAAI,SAAAC,GAAK,SAAAyC,EAAAlD,sBAAqB,EAAGS,KAEvE,KAAK,sBACD,MAAO,IAAIF,GAAAhB,kBAAkBpC,EAAKqD,IAAI,SAAAC,GAAK,SAAAyC,EAAAlD,sBAAqB,EAAGS,KAEvE,SACI,KAAM,IAAI9D,OAAM,qBAAuBC,KAAKC,UAAUW,KAalE,QAAgB2F,GAAoBC,GAChC,GAAIA,EACJ,OAAG,EAAAvD,EAAAvC,UAAS8F,GAAeA,EACfA,EAAMvG,YRuctBjB,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ0I,oBAAsB1I,EAAQwI,gBAAkBxI,EAAQuI,UAAYvI,EAAQqI,aAAW,EQ1gB/F,IAAAvC,GAAAtF,EAAA,GACA0F,EAAA1F,EAAA,GACA4E,EAAA5E,EAAA,GACAiI,EAAAjI,EAAA,EAWAR,GAAAqI,WAKArI,EAAAuI,YAWAvI,EAAAwI,kBAiCAxI,EAAA0I,uBR+fM,SAAUzI,EAAQD,EAASQ,GAEjC,YSviBA,SAAgBoI,GAAelG,GACrB,GAAAmG,GAAuBC,EAAgBpG,GAAtC4F,EAAGO,EAAAP,IAAEvF,EAAK8F,EAAA9F,KACjB,OAAO,IAAIgG,GAAeT,EAAKvF,GAGnC,QAAS+F,GAAgBpG,GACrB,IAAI,EAAAsG,EAAAX,UAAS3F,GACT,OAAO,EAAAsG,EAAAT,WAAU7F,EAEjB,IAAkB,WAAdA,EAAKgB,KACL,KAAM,IAAIxB,OAAM,oBAAsBC,KAAKC,UAAUM,GAEzD,OAAOoG,GAAgBpG,EAAKA,MAgBpC,QAAgBuG,GAAeC,GAC3B,GAAMC,KAKN,OAJAhI,QAAOiI,KAAKF,GAASG,QAAQ,SAAAf,GACpBa,EAASb,KACVa,EAASb,GAAOgB,KAA2BH,EAAUD,EAASA,EAAQZ,OAEvEa,EAGX,QAAgBI,GAAwBrI,EAAuBsI,EACvBC,EACAC,GACpC,MAAOxI,GAAEwB,KAAKqD,IAAI,SAAAU,GACd,IAAI,EAAArB,EAAAtC,UAAS2D,KAAU,EAAArB,EAAAvC,UAAS4D,GAAQ,MAAOA,EAC1C,KAAI,EAAAhB,EAAAC,aAAYe,GAAQ,MAAOkD,GAAiBH,EAAiBE,EAAMjD,EAAOgD,EAC9E,KAAI,EAAAhB,EAAAvD,sBAAqBuB,GAAQ,MAAOmD,GAAiCnD,EAAO+C,EAAiBC,EAAiBC,EAClH,MAAM,IAAIxH,SAIvB,QAAgBoH,GAAuBE,EACAC,EACAC,EACAhH,GACnC,OAAI,EAAA0C,EAAAvC,UAASH,GACFA,GACA,EAAAoD,EAAAlB,qBAAoBlC,KAAS,EAAAwD,EAAA1C,qBAAoBd,GACjDmH,EAAsCnH,EAAM8G,EAAiBC,EAAiBC,IAErF,EAAAjE,EAAAC,aAAYhD,GACLiH,EAAiBH,EAAiBE,EAAMhH,EAAM+G,GAMlD/G,EAGX,QAASiH,GAAiBH,EACAE,EACAhH,EACA+G,GTwiBtB,GAAIZ,GSviBEiB,EAAUpH,EAAKkD,SACrB,IAAI4D,EAAgBM,GAChB,KAAM,IAAI5H,OAAM,mBAAqB4H,EACzC,IAAIL,EAAgBK,GAChB,MAAOL,GAAgBK,EAE3B,KAAKJ,EAAKI,GACN,KAAM,IAAI5H,OAAM,0BAAA0E,OAA0BlE,EAAKkD,UAAS,OAAAgB,OAAMzE,KAAKC,UAAUM,GAAK,KAQtF,OANA+G,GAAgBK,GAAWR,EACvBnI,OAAO4I,UAAWP,GAAeX,KAAGA,EAACiB,IAAU,EAAIjB,IACnDY,EACAC,EACAA,EAAKI,IAEFL,EAAgBK,GAI3B,QAAgBF,GAAiCpE,EACAgE,EACAC,EACAC,GAC7C,GAAMM,GAAUT,EAAwB/D,EAAKgE,EAAiBC,EAAiBC,GAEzEjF,EAAqBe,EAAIf,UAC/B,KAAI,EAAAyB,EAAAvC,gBAAe6B,GACf,MAAO,IAAIU,GAAA5B,aAAaG,EAAYuF,EACxC,KAAI,EAAAlE,EAAAjB,gBAAeW,GACf,MAAO,IAAIM,GAAAf,aAAaN,EAAYuF,EACxC,KAAI,EAAA9D,EAAA1C,qBAAoBgC,GACpB,MAAO,IAAIU,GAAA7B,kBAAkB2F,EACjC,KAAI,EAAAlE,EAAAlB,qBAAoBY,GACpB,MAAO,IAAIM,GAAAhB,kBAAkBkF,EAE7B,MAAM,IAAI9H,OAGlB,QAAgB2H,GAAsCrE,EACAgE,EACAC,EACAC,GAClD,GAAMO,GAASL,EACXpE,EACAgE,EACAC,EACAC,EAEJ,MAAK,EAAA5D,EAAAlB,qBAAoBqF,MAAY,EAAA/D,EAAA1C,qBAAoByG,GAAS,KAAM,IAAI/H,MAC5E,OAAO+H,GTibX9I,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ6J,sCAAwC7J,EAAQ4J,iCAAmC5J,EAAQsJ,uBAAyBtJ,EAAQuJ,wBAA0BvJ,EAAQiJ,eAAiBjJ,EAAQ4I,eAAiB5I,EAAQ+I,mBAAiB,ESnkBzO,IAAAC,GAAAxI,EAAA,GACAiF,EAAAjF,EAAA,GACA0F,EAAA1F,EAAA,GACAsF,EAAAtF,EAAA,GACA4E,EAAA5E,EAAA,GAGAiI,EAAAjI,EAAA,GAKAuI,EAAA,WAMI,QAAAA,GAAmBT,EAAavF,GAC5BzC,KAAKoD,KAAO,SACZpD,KAAKgI,IAAMA,EACXhI,KAAKyC,MAAQA,EAErB,MAAAgG,KAXa/I,GAAA+I,iBAab/I,EAAA4I,iBA4BA5I,EAAAiJ,iBASAjJ,EAAAuJ,0BAWAvJ,EAAAsJ,yBA0CAtJ,EAAA4J,mCAmBA5J,EAAA6J,yCTuiBM,SAAU5J,EAAQD,EAASQ,GAEjC,YU/mBA,SAAS0J,GAAeC,GACpB,GAAMC,IAAW,EAAA3B,EAAArC,uBAAsB+D,EACvC,OAAOC,GAAWA,EAASC,OAAO,GAAK,GAO3C,QAASC,GAAuBC,GAC5B,MAAIA,GAAYpH,OAAS,GAAUqH,EAAoBD,EAAY,IAIvE,QAASC,GAAoBD,GACzB,IAAI,EAAAnF,EAAAtC,UAASyH,GAAc,CACvB,IAAKA,EAAa,OAAO,CACzB,IAAME,GAAKF,EAAYF,OAAO,EAC9B,OAAOI,GAAGC,gBAAkBD,GAAMA,EAAGE,gBAAkBF,EAG3D,IAAI,EAAAvE,EAAAvC,gBAAe4G,GAEf,SAAKA,EAAY7H,MAAQ6H,EAAY7H,KAAKS,QAAU,IAC7CqH,EAAoBD,EAAY7H,KAAK,GAGhD,KAAI,EAAA+C,EAAAC,aAAY6E,KACT,EAAArE,EAAA1C,qBAAoB+G,KACpB,EAAAzE,EAAAlB,qBAAoB2F,GACzB,KAAM,IAAIrI,OAAM,uCAElB,QAAO,EAGX,QAAS0I,GAAaC,GAOlB,IAAK,GANCC,IAAgC,EAAArC,EAAApB,gBAAewD,EAAOE,GAExDC,GAAqB,EACrBC,GAAmB,EACnBC,GAAyB,EAEpB7K,EAAI,EAAGA,EAAIyK,EAAa3H,OAAS,EAAG9C,IACrCiK,EAAuBQ,EAAazK,MAChC2K,EAAoB,IAEpBA,EAAoB3K,GAExB4K,EAAkB5K,EAAI,EAGF6K,GAAxBF,GAAqB,EAA2BA,EACvBF,EAAa3H,OAAS,CAEnD,IAAMgI,GAAuBH,GAAqB,EAAII,EAAoBN,EAAcE,EAAmBC,MACrGI,EAA6BD,EAAoBN,EAAc,EAAGI,GAClEI,EAA4BF,EAAoBN,EAAcS,KAAKC,IAAIP,EAAiBC,GAAwBJ,EAAa3H,OAEnI,OAAO,IAAIsI,GACPJ,EACAF,EACAG,MAKR,QAASI,GAAaC,EAA2BC,GAO7C,IAAK,GANCC,IAAU,EAAApD,EAAApB,gBAAesE,EAAYZ,GACrCe,GAAQ,EAAArD,EAAApB,gBAAeuE,EAAUb,GAEnCC,GAAqB,EACrBC,GAAmB,EAEd5K,EAAI,EAAGA,EAAIwL,EAAQ1I,OAAS,EAAG9C,IAChCiK,EAAuBuB,EAAQxL,MAC3B2K,EAAoB,IAAGA,EAAoB3K,GAC/C4K,EAAkB5K,EAAI,EAG9B,IAAM8K,GAAMH,GAAqB,EAAII,EAAoBS,EAAS,EAAGZ,MAC/DI,EAAYS,EACZR,EAAWF,EAAoBS,EAASN,KAAKC,IAAIP,EAAiB,GAExE,OAAO,IAAIQ,GACPJ,EACAF,EACAG,MAMR,QAASF,GAAuBW,EAAaC,EAAmBC,GAE5D,IAAK,GADChJ,MACG5C,EAAI2L,EAAW3L,OAAiBkC,KAAZ0J,EAAwBF,EAAO5I,OAAS8I,GAAU5L,IAC3E4C,EAAIM,KAAKwI,EAAO1L,GAEpB,OAAO4C,GAGX,QAASiJ,GAAeP,EAA2BQ,EAAsBP,GAQrE,IAAK,GAPCC,IAAU,EAAApD,EAAApB,gBAAesE,EAAYZ,GACrCe,GAAQ,EAAArD,EAAApB,gBAAeuE,EAAUb,GACjCqB,GAAK,EAAA3D,EAAApB,gBAAe8E,EAAOpB,GAE7BC,GAAqB,EACrBC,GAAmB,EAEd5K,EAAI,EAAGA,EAAIwL,EAAQ1I,OAAS,EAAG9C,IAChCiK,EAAuBuB,EAAQxL,MAC3B2K,EAAoB,IAAGA,EAAoB3K,GAC/C4K,EAAkB5K,EAAI,EAG9B,IAAM8K,GAAMH,GAAqB,EAAII,EAAoBS,EAAS,EAAGZ,MAC/DK,EAAWF,EAAoBS,EAASN,KAAKC,IAAIP,EAAiB,GAExE,OAAO,IAAIQ,GACPK,EACAX,EACAG,EACAc,GAaR,QAAgBC,GAAgBC,GAC5B,GAAMC,IAA8B,EAAA9D,EAAAnB,cAAagF,EAEjD,QAAQC,EAAWpJ,QACf,IAAK,GACD,MAAOyH,GAAa2B,EAAW,GACnC,KAAK,GACD,MAAOb,GAAac,EAAMD,EAAW,IAAKC,EAAMD,EAAW,IAC/D,KAAK,GACD,MAAOL,GAAeM,EAAMD,EAAW,IAAKC,EAAMD,EAAW,IAAKC,EAAMD,EAAW,IACvF,SACI,KAAM,IAAIrK,OAAM,+CAAA0E,OAA+CzE,KAAKC,UAAUmK,GAAW,QAAA3F,OAAOzE,KAAKC,UAAUkK,MAI3H,QAASG,GAAOhJ,GACZ,WAAalB,KAANkB,EAGX,QAAS+I,GAAM/I,GACX,GAAIgJ,EAAOhJ,GAAI,MAAOA,EAAQ,MAAM,IAAIvB,OAAM,WVudlDf,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQqM,gBAAkBrM,EAAQyL,eAAa,EUjrB/C,IAAArG,GAAA5E,EAAA,GACA0F,EAAA1F,EAAA,GACAiF,EAAAjF,EAAA,GACAsF,EAAAtF,EAAA,GACAiI,EAAAjI,EAAA,GAiBMuK,EAAc,OAEpBU,EAAA,WAoBI,QAAAA,GAAYiB,EAA6BC,EAAuBC,EAA4BC,GACxFvM,KAAKwM,YAAcJ,EACnBpM,KAAKyM,MAAQJ,EACbrM,KAAK0M,WAAaJ,EAClBtM,KAAK2M,KAAOJ,EAEZvM,KAAK4M,SAAWR,EAAW3G,IAAImE,GAE/B5J,KAAKoM,WAAaA,EAAW3G,IAAI0C,EAAArC,uBACjC9F,KAAKqM,KAAOA,EAAK5G,IAAI0C,EAAArC,uBACrB9F,KAAKsM,UAAYA,EAAU7G,IAAI0C,EAAArC,uBAC/B9F,KAAKuM,IAAMA,EAAI9G,IAAI0C,EAAArC,uBAEnB9F,KAAK6M,GAAK7M,KAAKoM,WAAWpH,KAAK,KAAO,IAChChF,KAAKqM,KAAKrH,KAAK,KAAO,IACtBhF,KAAKsM,UAAUtH,KAAK,KAAO,IAC3BhF,KAAKuM,IAAIvH,KAAK,KAE5B,MAAAmG,KAtCazL,GAAAyL,aA8KbzL,EAAAqM,mBV0oBM,SAAUpM,EAAQD,EAASQ,GAEjC,YWnzBA,SAAS4M,GAAY1K,GACjB,OAAO,EAAA2K,EAAAhB,iBAAgB3J,GAI3B,QAAgB4K,GAAsB5K,GAClC,OAAI,EAAA0C,EAAAvC,UAASH,GACF6K,GAAsB7K,IAEtB6K,EAAqB7K,EAAKA,MAAM,EAAAwD,EAAA1C,qBAAoBd,IAKnE,QAAS6K,GAAqB7K,EAAqB4D,GAC/C,GAAMkH,IAAU,EAAA/E,EAAA1B,wBACZ,EAAA0B,EAAApC,sBAAqB3D,EAAM4D,IAEzBmH,EAAkCD,EAAQzH,IAAI,SAAAC,GAAK,SAAAyC,EAAAtD,0BAAyBa,IAAK,EAAAyC,EAAApD,6BAA4BW,GAAKA,GACxH,QAAO,EAAAyC,EAAArB,YAAWqG,GAItB,QAAgBC,GAAcjK,GAC1B,IAAKkK,EAAUlK,GAAI,KAAM,IAAIvB,MAC7B,OAAOuB,GAIX,QAAgBkK,GAAUlK,GACtB,OAAQ,EAAA2B,EAAA3C,SAAQgB,EAAY,WAAiB,YAAXA,EAAEC,KXuxBxC,GAAIE,GAAatD,MAAQA,KAAKsD,WAAc,WACxC,GAAIC,GAAgB,SAAU9C,EAAG+C,GAI7B,OAHAD,EAAgB1C,OAAO4C,iBAChBC,uBAA2BpB,QAAS,SAAU7B,EAAG+C,GAAK/C,EAAEiD,UAAYF,IACvE,SAAU/C,EAAG+C,GAAK,IAAK,GAAIhC,KAAKgC,GAAO3C,OAAOS,UAAUC,eAAejB,KAAKkD,EAAGhC,KAAIf,EAAEe,GAAKgC,EAAEhC,MAC3Ef,EAAG+C,GAE5B,OAAO,UAAU/C,EAAG+C,GAIhB,QAASG,KAAO3D,KAAKqC,YAAc5B,EAHnC,GAAiB,kBAAN+C,IAA0B,OAANA,EAC3B,KAAM,IAAII,WAAU,uBAAyBC,OAAOL,GAAK,gCAC7DD,GAAc9C,EAAG+C,GAEjB/C,EAAEa,UAAkB,OAANkC,EAAa3C,OAAOiD,OAAON,IAAMG,EAAGrC,UAAYkC,EAAElC,UAAW,GAAIqC,OAGvF9C,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ2N,UAAY3N,EAAQ0N,cAAgB1N,EAAQsN,sBAAwBtN,EAAQ4N,YAAU,EWp2B9F,IAAAxI,GAAA5E,EAAA,GACA6M,EAAA7M,EAAA,GACA0F,EAAA1F,EAAA,GACA+D,EAAA/D,EAAA,GAEAiI,EAAAjI,EAAA,GAaAoN,EAAA,SAAApJ,GAGI,QAAAoJ,GAAYC,GAAZ,GAAA7I,GAAA1E,KACUoC,GAAO,EAAA0C,EAAAvC,UAASgL,IAAeA,GAAcA,EAAWnL,IAC9DsC,GAAAR,EAAA5D,KAAAN,KAAM,UAAWoC,IAAKpC,IAEtB,IAAMwN,GAAcR,EAAsBO,EXy1B1C,OWx1BA7I,GAAK+I,SAAWD,EAAY/H,IAAI,SAAA/E,GAAQ,MAAAoM,GAAYpM,KXw1B7CgE,EWt1Bf,MAV6BpB,GAAAgK,EAAApJ,GAU7BoJ,GAV6BrJ,EAAAI,wBAAhB3E,GAAA4N,UAkBb5N,EAAAsN,wBAkBAtN,EAAA0N,gBAMA1N,EAAA2N,aX01BM,SAAU1N,EAAQD,EAASQ,GAEjC,YYt3BA,SAAgBwN,GAAaxM,GACzB,MAAkB,YAAXA,EAAEkC,OAAsB,EAAA0B,EAAA3C,SAAQjB,EAAEkB,MAW7C,QAAgBuL,GAAiBvL,GAC7B,OAAO,EAAA0C,EAAApC,gBAAeN,GAAMqD,IAAImI,GZ22BpC/M,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQiO,iBAAmBjO,EAAQgO,aAAehO,EAAQmO,aAAenO,EAAQoO,eAAa,EY35B9F,IAAAhJ,GAAA5E,EAAA,GAEA4N,EAAA,WAKI,QAAAA,GAAY1L,GACRpC,KAAKoD,KAAO,UACZpD,KAAKoC,KAAOA,EACZpC,KAAKuF,OAASnD,EAAK4C,KAAK,IAMhC,MAHI8I,GAAAxM,UAAAwG,SAAA,WACI,MAAO9H,MAAKuF,QAEpBuI,IAdapO,GAAAoO,YAgBb,IAAAD,GAAA,WAKI,QAAAA,GAAYzK,EAAchB,GACtBpC,KAAKoD,KAAOA,EACZpD,KAAKoC,KAAOA,EACZpC,KAAKuF,OAASnD,EAAK4C,KAAK,IAMhC,MAHI6I,GAAAvM,UAAAwG,SAAA,WACI,MAAO9H,MAAKuF,QAEpBsI,IAdanO,GAAAmO,eAgBbnO,EAAAgO,cAIA,IAAME,GAAW,SAACG,GAAyB,SAAAjJ,EAAAtC,UAASuL,GAAWA,EACtC,gBAAZA,GAAuBA,EAAQjG,WAEd,SAApBiG,EAAc,KAAe,KAAM,EAAAjJ,EAAApD,cAAaqM,EAAQxI,QAChC,iBAApBwI,EAAc,KAAuB,KAAOH,EAASG,EAAQ3L,OACzD,EAAA0C,EAAApD,cAAaqM,EAAQxI,QAGvC7F,GAAAiO,oBZw5BM,SAAUhO,EAAQD,EAASQ,GAEjC,Ya33BA,SAAgB8N,GAAiBC,GAC7B,GAAMC,KAQN,OAPArN,QAAOiI,KAAKmF,GAAQlF,QAAQ,SAAAf,GAGhBkG,EAAOlG,IAAO,EAAAU,EAAAR,iBAAgB+F,EAAOjG,MAI1CkG,EAsBX,QAAgBC,GAAWhL,GACvB,MAA4B,gBAAdA,GAAQ,MACK,gBAAbA,GAAO,OACZA,EAAU,OAGvB,QAAgBiL,GAAaC,EAAiBC,GAU1C,GAAMC,MAEAC,EAAUH,EAAMJ,MAoBtB,OAlBApN,QAAOiI,KAAKuF,EAAMJ,QAAQlF,QAAQ,SAACf,GAC/B,GAAMyG,IAAS,EAAAC,EAAA1F,2BAA2BuF,EAAiBD,EAAUE,EAAQxG,GAC7E,QAAQA,GACJ,IAAK,SACDuG,EAAgBvG,GAAO,GAAI2G,GAAArB,QAAQmB,EACnC,MACJ,KAAK,QACDF,EAAgBvG,GAAO,CACvB,MACJ,KAAK,eAEL,QACIuG,EAAgBvG,GAAOyG,KAM5B,GAAIG,GACPP,EAAMjL,KACNiL,EAAMQ,IACNN,GbqzBR1N,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ0O,aAAe1O,EAAQyO,WAAazO,EAAQsO,iBAAmBtO,EAAQkP,aAAW,Ea38B1F,IAAAD,GAAAzO,EAAA,GAMAwO,EAAAxO,EAAA,GACAwI,EAAAxI,EAAA,GAKA0O,EAAA,WAgCI,QAAAA,GAAYxL,EAAcyJ,EAAYoB,GAClCjO,KAAKoD,KAAOA,EACZpD,KAAK6O,IAAMhC,EAEX7M,KAAKiO,OAASA,EAIdjO,KAAK8O,SAAW,GAChB9O,KAAK+O,OAAS,GAiBtB,MAdIH,GAAAtN,UAAA0N,SAAA,SAAShH,GACL,MAAOhI,MAAKiO,OAAOjG,EAAIoC,gBAG3BwE,EAAAtN,UAAA2N,iBAAA,SAAiBjH,GACb,GAAMK,GAAgCrI,KAAKgP,SAAShH,EACpD,QAAO,EAAAU,EAAAN,qBAAoBC,IAG/BuG,EAAAtN,UAAA4N,WAAA,WACI,GAAM7G,GAAQrI,KAAKiO,OAAe,MAClC,YAAchM,KAAVoG,EAA4BA,GACzB,EAAAsG,EAAAvB,eAAc/E,IAE7BuG,IA1DalP,GAAAkP,WAiEblP,EAAAsO,mBA+BAtO,EAAAyO,aAMAzO,EAAA0O,gBbg6BM,SAAUzO,EAAQD,EAASQ,GAEjC,YchgCA,SAAgBiP,GAAWhM,GACvB,MAAkB,aAAXA,EAAEC,QAAyBD,EAAEf,KAcxC,QAAgBgN,GAAgBhN,GAC5B,GAAMuD,IAAY,EAAA0J,EAAAC,+BAA6B,EAAAxK,EAAA5C,aAAYE,EAAKA,MAChE,OAAO,IAAImN,GAAS5J,Gdi/BxB9E,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ0P,gBAAkB1P,EAAQyP,WAAazP,EAAQ6P,aAAW,EcvhClE,IAAAzK,GAAA5E,EAAA,GACAmP,EAAAnP,EAAA,IAEAqP,EAAA,WAMI,QAAAA,GAAYnN,GACRpC,KAAKoD,KAAO,WACZpD,KAAKoC,KAAOA,EACZpC,KAAKuF,OAASnD,EAAK4C,KAAK,IAMhC,MAHIuK,GAAAjO,UAAAwG,SAAA,WACI,MAAO9H,MAAKuF,QAEpBgK,IAfa7P,GAAA6P,WAiBb7P,EAAAyP,aAeAzP,EAAA0P,mBdghCM,SAAUzP,EAAQD,EAASQ,GAEjC,Yeh9BA,SAASsP,GAAcC,GACnB,KAAK,EAAA3K,EAAA3C,SAAQsN,EAASrN,OAA2B,cAAlBqN,EAASrM,KAAsB,KAAM,IAAIxB,MACxE,OAAO,IAAI8N,GAAA5B,YAAW,EAAA4B,EAAA/B,kBAAiB8B,EAASrN,OAIpD,QAASuN,GAAWtB,GAChB,aAAeA,IACX,IAAK,SACD,GAAMjM,GAAOiM,EAAMjM,IACnB,IAA6B,gBAAlBA,GAAK,SACZ,MAAO,IAAIwN,GAAAhB,SACPxM,EAAK,SACLA,EAAKyM,KACL,EAAAe,EAAA5B,kBAAiB5L,EAAK6L,QAK9B,SADa,EAAAnJ,EAAApD,cAAaU,EAAKgB,OAE3B,IAAK,SACD,OAAO,EAAAsL,EAAApG,gBAAelG,EAC1B,KAAK,WACD,OAAO,EAAAyN,EAAAT,iBAAgBhN,EAO3B,SACI,KAAM,IAAIR,OAAM,4BAA8BQ,EAAKgB,MAE/D,QACI,KAAM,IAAIxB,OAAM,sCAiB5B,QAAgBkO,GAAaC,GACzB,GAAMvO,GAAI,GAAIwO,GAAQC,OAAOC,EAAAC,QAAQC,YAAaF,EAAAC,QAAQE,YAC1D7O,GAAE8O,KAAK,GAAIC,GAAAC,QAAMT,GAAOU,aACxB,IAAMC,GAAMlP,EAAEmP,QACRC,EAAQF,EAAI,EAElB,OAAO,IAAIG,IAAiB,EAAAnR,EAAA4P,8BAA6BsB,Ify5B7D/P,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQoQ,aAAepQ,EAAQ4P,6BAA+B5P,EAAQmR,qBAAmB,EexjCzF,IAAAb,GAAA9P,EAAA,IAEAgQ,EAAAhQ,EAAA,IAEA4E,EAAA5E,EAAA,GACAwI,EAAAxI,EAAA,GACA0P,EAAA1P,EAAA,IACAwP,EAAAxP,EAAA,IACA2P,EAAA3P,EAAA,IACAwO,EAAAxO,EAAA,GACAqQ,EAAArQ,EAAA,IAQA2Q,EAAA,WAgCI,QAAAA,GAAYC,GAAZ,GAAApM,GAAA1E,IACIA,MAAK8Q,QAAUA,EACf9Q,KAAK+Q,SAAWD,EAAQE,OAAOtB,EAAAhC,cAAcjI,IAAI,SAAAjF,GAC7C,IAAI,EAAAkP,EAAAhC,cAAalN,GAAG,MAAOA,EAAQ,MAAM,IAAIoB,SAKjD5B,KAAKiR,cAAgBH,EAAQE,OAAO,SAAAxQ,GAAK,SAAAqP,EAAAV,YAAW3O,KAAIiF,IAAI,SAAAjF,GACxD,IAAI,EAAAqP,EAAAV,YAAW3O,GAAI,MAAOA,EAAQ,MAAM,IAAIoB,SAEhD5B,KAAKkR,UAAYlR,KAAKiR,cAAcxL,IAAI,SAAAjE,GAAK,MAAAA,GAAEsG,aAAY9C,KAAK,KAEhE,IAAM4D,KACN5I,MAAK8Q,QAAQ/H,QAAQ,SAAAsF,GACb,IAAI,EAAA3F,EAAAX,UAASsG,GAAQ,CACjB,GAAMzF,EAAQyF,EAAMrG,KAChB,KAAM,IAAIpG,OAAM,kBAAoByM,EAAMrG,IAAM,8BACpDY,GAAQyF,EAAMrG,KAAOqG,EAAM5L,SAKvCzC,KAAKmR,YAAcvI,EACnB5I,KAAKsO,UAAW,EAAAI,EAAA/F,gBAAeC,GAE/B5I,KAAKoR,YAAcN,EAAQE,OAAO,SAAAxQ,GAAK,SAAAoP,EAAAzB,YAAW3N,KAAIiF,IAAI,SAAAjF,GACtD,IAAI,EAAAoP,EAAAzB,YAAW3N,GAAI,MAAOA,EACrB,MAAM,IAAIoB,QAGnB,IAAMyP,KACNrR,MAAKoR,YAAYrI,QAAQ,SAACsF,GACtB,GAAMrG,GAAMqG,EAAMQ,IAAIzE,aAOtB,IAAMiH,EAASrJ,GAAM,KAAM,IAAIpG,OAAM,iBAAmBoG,EAAM,8BAC9DqJ,GAASrJ,IAAO,EAAA4H,EAAAxB,cAAaC,EAAO3J,EAAK4J,YAE7CtO,KAAKsR,SAAWD,EAMxB,MAHIR,GAAAvP,UAAAiQ,SAAA,SAAS1E,GACL,MAAO7M,MAAKsR,SAASzE,EAAGzC,gBAEhCyG,IAjFanR,GAAAmR,kBAyHN,IAAMvB,GAA+B,SAAUsB,GAClD,MAAOA,GAAMnL,IAAI,SAAC+L,GACd,OAAQA,EAAOpO,MACX,IAAK,YACD,MAAQoM,GAAcgC,EAC1B,KAAK,QACD,MAAQ7B,GAAW6B,EACvB,SACI,KAAM,IAAI5P,OAAM,kCARnBlC,GAAA4P,6BAA4BA,EAazC5P,EAAAoQ,gBf4gCM,SAAUnQ,EAAQD,EAASQ,GAEjC,YgB/pCA,SAAgBuR,GAASrO,EAAcmC,GACnC,OACInC,KAAIA,EACJmC,OAAMA,GAoBd,QAAgBmM,GAAclR,GAC1B,MAAOd,GAAAiS,aAAapQ,eAAef,GAavC,QAAgBoR,GAAgBpR,GAC5B,MAAOd,GAAAmS,eAAetQ,eAAef,GhB2nCzCK,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQkS,gBAAkBlS,EAAQmS,eAAiBnS,EAAQgS,cAAgBhS,EAAQiS,aAAejS,EAAQ+R,aAAW,GgBlqCrH/R,EAAA+R,WAQa/R,EAAAiS,cACTG,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,KAAM,GAKV7S,EAAAgS,gBAKahS,EAAAmS,gBACTS,MAAM,EACNR,KAAK,EACLG,KAAK,EACLC,KAAK,GAKTxS,EAAAkS,mBhBmqCM,SAAUjS,EAAQD,EAASQ,GAEjC,YiB7sCA,SAAgBsS,GAAcjN,GAC1B,OACInC,KAAM,KACNmC,OAAMA,GAKd,QAAgBkN,GAAaC,GACzB,MAA+B,gBAAjBA,GAAMnN,QAAuBmN,EAAMtP,OAAS1D,EAAAiT,GAiB9D,QAAgBC,GAA4BpS,GACxC,MAAOd,GAAAmT,kBAAkBtR,eAAef,GjBorC5CK,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQkT,4BAA8BlT,EAAQmT,kBAAoBnT,EAAQ+S,aAAe/S,EAAQ8S,cAAgB9S,EAAQiT,OAAK,GiBltCjHjT,EAAAiT,GAAK,KAElBjT,EAAA8S,gBAQA9S,EAAA+S,eASa/S,EAAAmT,mBACTC,KAAK,EACLC,MAAM,EACNC,MAAM,EACNC,MAAM,GAKVvT,EAAAkT,+BjBitCM,SAAUjT,EAAQD,EAASQ,GAEjC,YkB7uCA,SAAgBgT,GAAU3N,GACtB,OACInC,KAAM,SACNmC,OAAMA,GAuBd,QAAgB4N,GAAM3S,GAClB,MAAOd,GAAA0T,aAAa7R,eAAef,GlBotCvCK,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQyT,MAAQzT,EAAQ0T,aAAe1T,EAAQwT,cAAY,GkBhvC3DxT,EAAAwT,YAWaxT,EAAA0T,cACTC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,EACLC,GAAK,GAKTpU,EAAAyT,SlBkvCM,SAAUxT,EAAQD,EAASQ,GAEjC,YAEA,IAAI6T,GAAmB/T,MAAQA,KAAK+T,kBAAqBlT,OAAOiD,OAAS,SAAUlD,EAAGL,EAAGyT,EAAGC,OAC7EhS,KAAPgS,IAAkBA,EAAKD,GAC3BnT,OAAOC,eAAeF,EAAGqT,GAAMjT,YAAY,EAAMC,IAAK,WAAa,MAAOV,GAAEyT,OAC3E,SAAUpT,EAAGL,EAAGyT,EAAGC,OACThS,KAAPgS,IAAkBA,EAAKD,GAC3BpT,EAAEqT,GAAM1T,EAAEyT,KAEVE,EAAgBlU,MAAQA,KAAKkU,cAAiB,SAAS3T,EAAGb,GAC1D,IAAK,GAAI8B,KAAKjB,GAAa,YAANiB,GAAoBX,OAAOS,UAAUC,eAAejB,KAAKZ,EAAS8B,IAAIuS,EAAgBrU,EAASa,EAAGiB,GAE3HX,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,ImB9xCtDyR,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,GAAAR,GACAwU,EAAAhU,EAAA,IAAAR,GACAwU,EAAAhU,EAAA,GAAAR,InBoyCM,SAAUC,EAAQD,EAASQ,GAEjC,YoB3mCA,SAAgBiU,GAAkB1S,GAC9B,MAAO/B,GAAA0U,eAAe7S,eAAeE,GAGzC,QAAgB4S,GAAmB5S,GAC/B,MAAO/B,GAAA4U,gBAAgB/S,eAAeE,GAG1C,QAAgB8S,GAAmB9S,GAC/B,MAAI4S,GAAmB5S,GACZ/B,EAAA4U,gBAAgB7S,MAM/B,QAAgB+S,GAAkB/S,GAC9B,MAAI0S,GAAkB1S,GACX/B,EAAA0U,eAAe3S,MpB2lC9BZ,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ+U,UAAY/U,EAAQ8U,kBAAoB9U,EAAQ6U,mBAAqB7U,EAAQ2U,mBAAqB3U,EAAQyU,kBAAoBzU,EAAQ4U,gBAAkB5U,EAAQ0U,eAAiB1U,EAAQgV,KAAOhV,EAAQiV,OAASjV,EAAQ0D,KAAO1D,EAAQkV,MAAQlV,EAAQmV,OAASnV,EAAQoV,OAASpV,EAAQqV,UAAYrV,EAAQsV,MAAQtV,EAAQuV,aAAevV,EAAQwV,OAASxV,EAAQyV,KAAOzV,EAAQ0V,MAAQ1V,EAAQ2V,QAAU3V,EAAQ4V,YAAc5V,EAAQ6V,aAAe7V,EAAQ8V,OAAS9V,EAAQ+V,QAAU/V,EAAQgW,QAAUhW,EAAQiW,UAAYjW,EAAQkW,OAASlW,EAAQmW,YAAU,EoBxzChjB,IAAA/Q,GAAA5E,EAAA,EA0HaR,GAAAmW,QAAU,UACVnW,EAAAkW,OAAS,SACTlW,EAAAiW,UAAY,YACZjW,EAAAgW,QAAU,UACVhW,EAAA+V,QAAU,UACV/V,EAAA8V,OAAS,SACT9V,EAAA6V,aAAe,eACf7V,EAAA4V,YAAc,cACd5V,EAAA2V,QAAU,UACV3V,EAAA0V,MAAQ,QACR1V,EAAAyV,KAAO,OACPzV,EAAAwV,OAAS,SACTxV,EAAAuV,aAAe,eACfvV,EAAAsV,MAAQ,QACRtV,EAAAqV,UAAY,YACZrV,EAAAoV,OAAS,SACTpV,EAAAmV,OAAS,SACTnV,EAAAkV,MAAQ,QACRlV,EAAA0D,KAAO,OACP1D,EAAAiV,OAAS,SACTjV,EAAAgV,KAAO,OA2BPhV,EAAA0U,gBACT0B,OAAU,SAAU,UAAW,SAAU,UAAW,UAAW,QAAS,QACxEC,SAAY,SAAU,eAAgB,UAAW,UAAW,QAAS,OAAQ,QAC7EC,YAAe,UAAW,SAAU,UAAW,SAAU,QAAS,UAAW,QAAS,eAAgB,YAAa,QACnHC,eAAkB,UAAW,SAAU,UAAWvW,EAAAmV,OAAQ,QAAS,UAAW,QAAS,eAAgB,YAAa,QACpHqB,QAAW,SAAU,SAAU,SAAU,OAAQ,UAAW,UAAW,QAAS,QAChFC,cAAiB,UAAW,SAAU,UAAW,SAAU,OAAQ,UAAW,QAAS,UAAW,UAAW,QAAS,QACtHC,QAAW,SAAU,eAAgB,OAAQ,UAAW,UAAW,QAAS,QAC5EC,eAAkB,OAAQ,UAAW,QAAS,QAC9CC,QACAC,WAAc,OAAQ,UAAW,QAAS,QAC1CC,aAAgB,UAAW,SAAU,UAAW,SAAU,UAAW,QAAS,eAAgB,YAAa,QAC3GC,YAAe,OAAQ,UAAW,SAAU,QAAS,QACrDC,aAAgB,QAAS,SAGhBhX,EAAA4U,iBACTqC,SAAY,SAAU,QAAS,OAAQ,WACvCb,OAAU,SAAU,UAAW,QAAS,YAAa,QACrDC,SAAY,SACZC,YAAe,SAAU,QAAS,YAAa,QAC/CC,eAAkB,SAAU,QAAS,YAAa,QAClDC,SAAY,SAAU,UAAW,SAAU,UAAW,UACtDC,cAAiB,SAAU,QAAS,YAAa,YAAa,QAC9DC,QAAW,SACXC,eAAkB,SAAU,QAAS,SAAU,QAC/CC,OAAU,SAAU,QAAS,eAAgB,OAAQ,QAAS,SAC9DC,WAAc,SAAU,QAAS,SAAU,QAC3CC,aAAgB,OAAQ,SACxBC,YAAe,SAAU,QAAS,cAAe,QACjDC,aAAgB,SAAU,QAAS,SAGvChX,EAAAyU,oBAIAzU,EAAA2U,qBAIA3U,EAAA6U,qBAQA7U,EAAA8U,mBAQO,IAAMC,GAAY,SAACpG,EAAiBhG,GACvC,GAAM4F,GAASI,EAAMJ,MACrB,KAAI,EAAAnJ,EAAAtC,UAAS6F,IACT,IAAK4F,EAAO5F,GACR,MAAO,IAAIzG,OAAM,qBAAuByM,EAAMjL,KAAO,YAAciL,EAAMQ,IACnE,uBAAyBxG,OAChC,KAAI,EAAAvD,EAAA3C,SAAQkG,GAAQ,CACvB,GAAMuO,GAAwBvO,EAAMwO,OAChC,SAACC,EAAcC,GACX,IAAI,EAAAjS,EAAAtC,UAASuU,GACT,MAAQD,IAAO7I,EAAO1M,eAAewV,EAGrC,MAAM,IAAInV,SACf,EAEP,KAAKgV,EAED,MAAO,IAAIhV,OAAM,YAAcyM,EAAMjL,KAAO,YAAciL,EAAMQ,IAC1D,yCAA2CxG,IAnBhD3I,GAAA+U,UAASA,GpBgsChB,SAAU9U,EAAQD,IqBl6CxB,SAAAF,EAAAC,GACA,gBAAAE,MAAAD,QACAC,EAAAD,QAAAD,IAEAD,EAAAwQ,QAAAvQ,KAECO,KAAA,WAED,QAAAgX,GAAAtW,EAAAuW,EAAAC,GAKA,MAJAlX,MAAA6M,KAAAmK,EAAAG,UACAnX,KAAAU,OACAV,KAAAiX,UACAjX,KAAAkX,cACAlX,KAmBA,QAAAoX,GAAAC,EAAAC,EAAAC,EAAAC,GACAxX,KAAAqX,OACArX,KAAAsX,MACAtX,KAAAuX,YACAvX,KAAAoC,QACApC,KAAAwX,WACAxX,KAAAyX,WAAAzX,KAAAsX,MAAAD,EAAAJ,QAAApU,OAmCA,QAAA6U,GAAAvH,EAAAxI,GACA3H,KAAAmQ,UACAnQ,KAAA2H,QACA3H,KAAA2X,UACA3X,KAAA4X,SACA5X,KAAA6X,aACA7X,KAAA8X,aA6EA,QAAAC,GAAAC,EAAAC,GACAjY,KAAAgY,QACAhY,KAAAiY,SAAAjY,KAAAgY,MAAA,GAAAtX,IACA,IAAAwX,GAAAlY,KAAAkY,SACAlY,MAAAgY,MAAAjP,QAAA,SAAAsO,GACAa,EAAA3W,eAAA8V,EAAA3W,QACAwX,EAAAb,EAAA3W,UAEAwX,EAAAb,EAAA3W,MAAAuC,KAAAoU,KAkBA,QAAAc,KACAnY,KAAAoY,MAAA,IA+CA,QAAAnI,GAAA+H,EAAAC,EAAAI,GACA,GAAAL,YAAAD,GACA,GAAA5H,GAAA6H,EACAK,EAAAJ,MAEA,IAAA9H,GAAA4H,EAAAO,aAAAN,EAAAC,EAEAjY,MAAAmQ,UAGAnQ,KAAAqY,SACAE,aAAA,EACAC,MAAArI,EAAAqI,OAAA,GAAAL,GAEA,QAAAnQ,KAAAqQ,OACArY,KAAAqY,QAAArQ,GAAAqQ,EAAArQ,EAIAhI,MAAAwY,MAAAxY,KAAAqY,QAAAG,MACAxY,KAAAyY,eAAAxW,EAGA,IAAAyW,GAAA,GAAAhB,GAAAvH,EAAA,EACAnQ,MAAA2Y,OAAAD,EAGAA,GAAAd,MAAAzH,EAAA8H,UACAS,EAAAE,QAAAzI,EAAA8H,OAEAS,EAAAG,UACA7Y,KAAA8Y,QAAA,EA6HA,MAnXA9B,GAAAG,UAAA,EAEAH,EAAA1V,UAAAwG,SAAA,SAAAiR,GACA,QAAAC,GAAAtT,GACA,MAAAA,GAAAuT,QAAApX,KAAAC,UAAA4D,EAAAuT,SACAvT,EAAAtC,KAAA,IAAAsC,EAAAtC,KAAAsC,EAAAoC,WAEA,GAAAoR,OAAA,KAAAH,EACA/Y,KAAAiX,QAAAxR,IAAAuT,GAAAhU,KAAA,KACAhF,KAAAiX,QAAAkC,MAAA,EAAAJ,GAAAtT,IAAAuT,GAAAhU,KAAA,KACA,MACAhF,KAAAiX,QAAAkC,MAAAJ,GAAAtT,IAAAuT,GAAAhU,KAAA,IACA,OAAAhF,MAAAU,KAAA,MAAAwY,GAcA9B,EAAA9V,UAAAwG,SAAA,WACA,UAAa9H,KAAAqX,KAAAvP,SAAA9H,KAAAsX,KAAA,aAAqCtX,KAAAuX,WAAA,IAGlDH,EAAA9V,UAAA8X,UAAA,SAAAC,GACA,GAAAC,GAAA,GAAAlC,GAAApX,KAAAqX,KAAArX,KAAAsX,IAAA,EAAAtX,KAAAuX,UAAAvX,KAAAwX,SAMA,OALA8B,GAAAC,KAAAvZ,KACAsZ,EAAAE,MAAAH,EACAC,EAAA7B,aACA6B,EAAAlX,KAAAkX,EAAAG,SAEAH,GAGAlC,EAAA9V,UAAAmY,MAAA,WACA,GAAAC,MACAC,EAAA3Z,IACA,IACA0Z,EAAAzW,KAAA0W,EAAAH,MAAApX,MACAuX,IAAAJ,WACKI,EAAAJ,KAEL,OADAG,GAAAE,UACAF,GAGAtC,EAAA9V,UAAAuY,OAAA,WACA7Z,KAAAqX,KAAAH,cACAlX,KAAAoC,KAAApC,KAAAqX,KAAAH,YAAAlX,KAAAoC,KAAApC,KAAAuX,UAAAtH,EAAA6J,QAeApC,EAAApW,UAAAuX,QAAA,SAAAkB,GAKA,OAJApC,GAAA3X,KAAA2X,OACAC,EAAA5X,KAAA4X,MACAE,EAAA9X,KAAA8X,UAEAkC,EAAA,EAAmBA,EAAArC,EAAA9U,OAAmBmX,IAAA,CACtC,GAAAV,GAAA3B,EAAAqC,EAEA,IAAAV,EAAA7B,YAEA,GADA6B,EAAAO,SACAP,EAAAlX,OAAA6N,EAAA6J,KAAA,CAGA,OADAtC,GAAA8B,EAAA9B,SACAzX,EAAAyX,EAAA3U,OAA6C9C,KAAK,CAClD,GAAAwZ,GAAA/B,EAAAzX,EACAC,MAAAia,SAAAV,EAAAD,GAIA,GAAAA,EAAA/B,YAAAvX,KAAA2H,MAAA,CAEA,GAAAuS,GAAAZ,EAAAjC,KAAA3W,MACAV,KAAA8X,UAAAoC,GAAAla,KAAA8X,UAAAoC,QAAAjX,KAAAqW,SAIS,CAET,GAAAY,GAAAZ,EAAAjC,KAAAJ,QAAAqC,EAAAhC,IACA,oBAAA4C,GAAA,CACAla,KAAA6X,UAAA5U,KAAAqW,EACA,UAIA,GAAA1B,EAAAsC,IAGA,GAFAtC,EAAAsC,GAAAjX,KAAAqW,GAEAxB,EAAAvW,eAAA2Y,GAEA,OADAC,GAAArC,EAAAoC,GACAna,EAAA,EAAmCA,EAAAoa,EAAAtX,OAAkB9C,IAAA,CACrD,GAAAyZ,GAAAW,EAAApa,EACAC,MAAAia,SAAAX,EAAAE,QAIA5B,GAAAsC,IAAAZ,GACAtZ,KAAA4Y,QAAAsB,MAMAxC,EAAApW,UAAAsX,QAAA,SAAAsB,GAGA,OAFAlC,GAAAhY,KAAAmQ,QAAA+H,OAAAgC,OAEAna,EAAA,EAAmBA,EAAAiY,EAAAnV,OAAkB9C,IAAA,CACrC,GAAAqa,GAAApC,EAAAjY,GACAyX,EAAAxX,KAAA4X,MAAAsC,GACAzY,EAAA,GAAA2V,GAAAgD,EAAA,EAAApa,KAAA2H,MAAA6P,EACAxX,MAAA2X,OAAA1U,KAAAxB,KAIAiW,EAAApW,UAAA2Y,SAAA,SAAAV,EAAAC,GACA,GAAAa,GAAAb,EAAAnC,KAAA3W,IACA,IAAA6Y,EAAAlC,KAAAJ,QAAAsC,EAAAjC,OAAA+C,EAAA,CACA,GAAAC,GAAAf,EAAAH,UAAAI,EACAxZ,MAAA2X,OAAA1U,KAAAqX,KAkBAvC,EAAAO,aAAA,SAAAN,EAAAC,GACA,GAAAO,GAAAR,EAAAuC,KACAvC,GAAA3H,cACA4H,EAAAD,EAAA3H,YACA2H,IAAA5H,YAEA,IAAA4H,KAAAvS,IAAA,SAAA2U,GAAwC,UAAApD,GAAAoD,EAAA1Z,KAAA0Z,EAAAnD,QAAAmD,EAAAlD,eACxCsD,EAAA,GAAAzC,GAAAC,EAAAC,EAEA,OADAuC,GAAAhC,QACAgC,GAQArC,EAAA7W,UAAA8W,MAAA,SAAAhW,EAAAkX,GACAtZ,KAAAqH,OAAAjF,EACApC,KAAA2H,MAAA,EACA3H,KAAAya,KAAAnB,IAAAmB,KAAA,EACAza,KAAA0a,cAAApB,KAAAqB,IAAA,GAGAxC,EAAA7W,UAAAsZ,KAAA,WACA,GAAA5a,KAAA2H,MAAA3H,KAAAqH,OAAAxE,OAAA,CACA,GAAAsH,GAAAnK,KAAAqH,OAAArH,KAAA2H,QAKA,OAJA,OAAAwC,IACAnK,KAAAya,MAAA,EACAza,KAAA0a,cAAA1a,KAAA2H,QAEgBlF,MAAA0H,KAIhBgO,EAAA7W,UAAAuZ,KAAA,WACA,OACAJ,KAAAza,KAAAya,KACAE,IAAA3a,KAAA2H,MAAA3H,KAAA0a,gBAIAvC,EAAA7W,UAAAwZ,YAAA,SAAApI,EAAAqI,GAGA,GAAA1T,GAAArH,KAAAqH,MACA,oBAAAA,GAAA,CACA,GAAA2T,GAAA3T,EAAA4T,QAAA,KAAAjb,KAAA2H,QACA,IAAAqT,MAAA3T,EAAAxE,OACA,IAAA4X,GAAApT,EAAAO,UAAA5H,KAAA0a,cAAAM,GACAL,EAAA3a,KAAA2H,MAAA3H,KAAA0a,aAIA,OAHAK,IAAA,YAAA/a,KAAAya,KAAA,QAAAE,EAAA,QACAI,GAAA,KAAAN,EAAA,KACAM,GAAA,KAAAzY,MAAAqY,GAAA3V,KAAA,SAGA,MAAA+V,GAAA,cAAA/a,KAAA2H,MAAA,IAwCAsI,EAAA6J,QAEA7J,EAAA3O,UAAAgP,KAAA,SAAA4K,GACA,GAAA1C,GAAAxY,KAAAwY,KACAA,GAAAJ,MAAA8C,EAAAlb,KAAAyY,WAGA,KADA,GAAA/F,GACAA,EAAA8F,EAAAoC,QAAA,CAEA,GAAAlC,GAAA1Y,KAAA2Y,MAAA3Y,KAAA8Y,QAGA9Y,MAAAqY,QAAAE,mBACAvY,MAAA2Y,MAAA3Y,KAAA8Y,QAAA,EAGA,IAAA5X,GAAAlB,KAAA8Y,QAAA,EACAiB,EAAA,GAAArC,GAAA1X,KAAAmQ,QAAAjP,EACAlB,MAAA2Y,MAAA1V,KAAA8W,EAMA,QAHAd,GAAAvG,EAAAjQ,MACAA,EAAA+V,EAAAnW,cAAA8V,EAAAzF,EAAAjQ,MAAAiQ,EACAmF,EAAAa,EAAAb,UACAmC,EAAAnC,EAAAhV,OAAsCmX,KAAK,CAC3C,GAAAV,GAAAzB,EAAAmC,GACAmB,EAAA7B,EAAAjC,KAAAJ,QAAAqC,EAAAhC,IAGA,IAAA6D,EAAAC,KAAAD,EAAAC,KAAA3Y,GACA0Y,EAAA/X,KAAA+X,EAAA/X,OAAAsP,EAAAtP,KACA+X,EAAAlC,YAAA,CAEA,GAAA2B,GAAAtB,EAAAF,WAA4ChX,KAAAK,EAAAiQ,QAAA2I,SAAA,EAAA9D,UAAArW,EAAA,GAC5C6Y,GAAApC,OAAA1U,KAAA2X,IAeA,GAHAb,EAAAlB,UAGA,IAAAkB,EAAApC,OAAA9U,OAAA,CAEA,GAAAkY,GAAA/a,KAAAwY,MAAAsC,YAAApI,EAAA,sBACAqI,IAAA,eAAArI,EAAAtP,KAAAsP,EAAAtP,KAAA,eACA2X,GAAAlZ,KAAAC,cAAAG,KAAAyQ,EAAAjQ,MAAAiQ,EAAAjQ,MAAAiQ,GAAA,IACA,IAAA4I,GAAA,GAAA1Z,OAAAmZ,EAGA,MAFAO,GAAAC,OAAAvb,KAAA8Y,QACAwC,EAAA5I,QACA4I,EAIAtb,KAAAqY,QAAAE,cACAG,EAAAD,WAAAD,EAAAqC,QAGA7a,KAAA8Y,UAUA,MARAJ,KACA1Y,KAAAyY,WAAAD,EAAAqC,QAIA7a,KAAA2Q,QAAA3Q,KAAA6Z,SAGA7Z,MAGAiQ,EAAA3O,UAAAuZ,KAAA,WACA,GAAAnC,GAAA1Y,KAAA2Y,MAAA3Y,KAAA8Y,QAEA,OADAJ,GAAAD,WAAAzY,KAAAyY,WACAC,GAGAzI,EAAA3O,UAAAka,QAAA,SAAA9C,GACA,GAAA/Q,GAAA+Q,EAAA/Q,KACA3H,MAAA8Y,QAAAnR,EACA3H,KAAA2Y,MAAAhR,GAAA+Q,EACA1Y,KAAA2Y,MAAA8C,OAAA9T,EAAA,GACA3H,KAAAyY,WAAAC,EAAAD,WAGAzY,KAAA2Q,QAAA3Q,KAAA6Z,UAIA5J,EAAA3O,UAAAoa,OAAA,SAAA/T,GACA,IAAA3H,KAAAqY,QAAAE,YACA,SAAA3W,OAAA,+CAIA5B,MAAAwb,QAAAxb,KAAA2Y,MAAAhR,KAGAsI,EAAA3O,UAAAuY,OAAA,WAEA,GAAA8B,MACA1D,EAAAjY,KAAAmQ,QAAA8H,KAUA,OATAjY,MAAA2Y,MAAA3Y,KAAA2Y,MAAA9V,OAAA,GACA8U,OAAA5O,QAAA,SAAA/G,GACAA,EAAAqV,KAAA3W,OAAAuX,GACAjW,EAAAsV,MAAAtV,EAAAqV,KAAAJ,QAAApU,QACA,IAAAb,EAAAuV,WACAvV,EAAAI,OAAA6N,EAAA6J,MACA6B,EAAA1Y,KAAAjB,KAGA2Z,EAAAlW,IAAA,SAAAjF,GAA2C,MAAAA,GAAA4B,SAI3C6N,SACA8H,UACAf,WrB46CM,SAAUrX,EAAQD,EAASQ,GAEjC,YsBnzDA,SAAS2M,GAAG1J,GACR,MAAOA,GAAE,GAgDb,QAASyY,GAAS1W,EAAK2W,GACnB,GAAoB,WAAhBA,EAAOzY,KAAmB,KAAM,IAAIxB,OAAM,2BAC9C,IAAMoG,GAAM6T,EAAO7T,IAAIoC,aACvB,OAAIlF,GAAI+I,OAAOjG,OAGX,IAEA9C,EAAI+I,OAAOjG,GAAO6T,EAAOpZ,MAClByC,GAIf,QAAS4W,GAAWnZ,GAEhB,IAAK,GADCoZ,MACGhc,EAAI,EAAGA,EAAI4C,EAAIE,OAAQ9C,IAC5B,GAAsB,gBAAX4C,GAAI5C,GAAiB,CAC5B,IAAK4C,EAAI5C,GAAGwF,OAAQ,KAAM,IAAI3D,OAAM,mEAAqEC,KAAKC,UAAUa,EAAI5C,IAC5Hgc,GAAK9Y,KAAKN,EAAI5C,GAAGwF,YACd,IAAsB,gBAAX5C,GAAI5C,IAAqC,gBAAX4C,GAAI5C,GAE7C,KAAM,IAAI6B,OAAM,0BAA4BC,KAAKC,UAAUa,EAAI5C,IAAM,aAAe8B,KAAKC,UAAUa,GADtGoZ,GAAK9Y,KAAKN,EAAI5C,IAGtB,MAAOgc,GAAK/W,KAAK,ItB6uDrBnE,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQyQ,YAAU,EsBlzDlB,IAAM5N,GAAW,SAAUY,GACvB,MAAOA,GAAEd,cAAgB2Z,QAAwB,gBAAN7Y,IAA6B,WAAXA,EAAEC,MAE7D6Y,GACFb,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,OAAXA,EAAEC,OAGpC8Y,GACFd,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,SAAXA,EAAEC,OAGpC+Y,GACFf,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,YAAXA,EAAEC,OAGpCgZ,GACFhB,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,cAAXA,EAAEC,OAGpCiZ,GACFjB,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,aAAXA,EAAEC,OAGpCkZ,GACFlB,KAAM,SAAUjY,GACZ,MAAoB,gBAANA,IAA6B,OAAXA,EAAEC,OAGpCmZ,GAAYnB,KAAM7Y,GAClBia,GAAcvD,QAAS,KACvBwD,GAAWxD,QAAS,KACpByD,GAAYzD,QAAS,MACrB0D,GAAW1D,QAAS,KACpB2D,GAAW3D,QAAS,KACpB4D,GAAW5D,QAAS,KACpB6D,GAAW7D,QAAS,KACpB8D,GAAa9D,QAAS,KACtB+D,GAAc/D,QAAS,IA6BhBvZ,GAAAyQ,SACToK,UAAOtY,GACPmO,cACK1P,KAAQ,cAAeuW,SAAY,aAAcC,YAAerK,IAE7DnM,KAAQ,cAAeuW,WAAeC,YAAe,eAIxDxW,KAAQ,cAAeuW,aACvBvW,KAAQ,qCAAsCuW,SAAY,aAAcC,YAAerK,IAEpFnM,KAAQ,qCAAsCuW,WAAeC,YAAe,eAI/ExW,KAAQ,8BAA+BuW,SAAY,QAAS,wCAEzDvW,KAAQ,cACRuW,SAAY,cAAe,+BAC3BC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,OACRuW,SAAY,cAAe,eAC3BC,YAAe,SAAU9U,GACrB,GAAM6a,KAEF7a,GAAK,IACL6a,EAAgBha,MAAMG,KAAM,YAAahB,KAAMA,EAAK,IAExD,KAAK,GAAIrC,GAAI,EAAGA,EAAIqC,EAAK,GAAGS,OAAQ9C,IAEhCkd,EAAgBha,MAAMG,KAAM,QAAShB,KAAMA,EAAK,GAAGrC,GAAG,KAElDqC,EAAK,GAAGrC,GAAG,IACXkd,EAAgBha,MAAMG,KAAM,YAAahB,KAAMA,EAAK,GAAGrC,GAAG,IAElE,OAAOkd,MAGdvc,KAAQ,WAAYuW,aAEjBvW,KAAQ,WAAYuW,SAAY,WAAYqF,GAAKpF,YAAe,SAAiBzW,GACjF,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAGzBC,KAAQ,IAAKuW,SAAY,cACzBvW,KAAQ,6BAA8BuW,SAAYiF,KAClDxb,KAAQ,6BAA8BuW,SAAYkF,KAClDzb,KAAQ,6BAA8BuW,SAAYmF,KAClD1b,KAAQ,6BAA8BuW,SAAYoF,KAE/C3b,KAAQ,aACRuW,SAAY,8BACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,MAGtB1B,KAAQ,wBAAyBuW,SAAY,eAC7CvW,KAAQ,wBAAyBuW,SAAY,kBAC7CvW,KAAQ,wBAAyBuW,SAAY,oBAC7CvW,KAAQ,wBAAyBuW,SAAY,mBAE1CvW,KAAQ,QAASuW,SAAY,yBAA0BC,YAAe,SAAU9U,GAChF,MAAOA,GAAK,GAAG,MAIf1B,KAAQ,UAAWuW,SAAY,QAASC,YAAe,SAAU9U,GACjE,MAAOA,GAAK,MAGf1B,KAAQ,yBAA0BuW,aAClCvW,KAAQ,yCAA0CuW,SAAY,OAE3DvW,KAAQ,yBACRuW,SAAY,yBAA0B,0CACtCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,kBACRuW,SAAY,0BACZC,YAAe,SAAU9U,GAErB,IAAK,GADC8a,MACGC,EAAK,EAAGA,EAAK/a,EAAK,GAAGS,OAAQsa,IAClCD,EAAOja,KAAKb,EAAK,GAAG+a,GAAI,GAC5B,OAAOD,MAGdxc,KAAQ,iDAAkDuW,SAAY,aAEnEvW,KAAQ,iDACRuW,SAAY0F,EAAS,iDAAkDC,GACvE1F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,qCAAsCuW,SAAY,oDAC1DvW,KAAQ,iDAAkDuW,SAAY,aAEnEvW,KAAQ,iDACRuW,SAAY4F,EAAS,iDAAkDC,GACvE5F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,qCAAsCuW,SAAY,oDAEvDvW,KAAQ,qBACRuW,SAAY,sCACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,GAAG,MAGzB1B,KAAQ,gDAAiDuW,SAAY,YAElEvW,KAAQ,gDACRuW,SAAY0F,EAAS,IAAK,gDAAiD,IAAKC,GAChF1F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,oCAAqCuW,SAAY,mDACzDvW,KAAQ,gDAAiDuW,SAAY,YAElEvW,KAAQ,gDACRuW,SAAY4F,EAAS,IAAK,gDAAiD,IAAKC,GAChF5F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,oCAAqCuW,SAAY,mDAEtDvW,KAAQ,oBACRuW,SAAY,qCACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,GAAG,MAGzB1B,KAAQ,6CAA8CuW,SAAY,iBAE/DvW,KAAQ,6CACRuW,SAAY0F,EAAS,IAAK,6CAA8C,IAAKC,GAC7E1F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,iCAAkCuW,SAAY,gDACtDvW,KAAQ,6CAA8CuW,SAAY,iBAE/DvW,KAAQ,6CACRuW,SAAY4F,EAAS,IAAK,6CAA8C,IAAKC,GAC7E5F,YAAe,SAAU9U,GACrB,MAAOA,GAAK,MAGnB1B,KAAQ,iCAAkCuW,SAAY,gDAEnDvW,KAAQ,iBACRuW,SAAY,kCACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,GAAG,MAGzB1B,KAAQ,qBAAsBuW,aAC9BvW,KAAQ,qCAAsCuW,SAAY,SAAU,IAAK+F,EAAO,OAE7Etc,KAAQ,qBACRuW,SAAY,qBAAsB,sCAClCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAG7BC,KAAQ,qCAAsCuW,SAAY,IAAK+F,KAC/Dtc,KAAQ,qBAAsBuW,SAAY,sCAAuCC,YAAerK,IAE7FnM,KAAQ,qBAAsBuW,WAAeC,YAAe,eAK5DxW,KAAQ,cACRuW,SAAY,aAAc,IAAK+F,EAAO,IAAK,qBAAsB,SAAU,sBAC3E9F,YAAe,SAAU9U,GAMrB,IAAK,GALC8C,IACF2J,IAAKzM,EAAK,GACV6L,WAEEmP,EAAUhb,EAAK,GACZib,EAAK,EAAGA,EAAKD,EAAQva,OAAQwa,IAClCnY,EAAI+I,OAAOhL,KAAKma,EAAQC,GAAI,GAGhC,OADAnY,GAAI+I,OAAOhL,KAAKb,EAAK,IACd8C,KAIXxE,KAAQ,YACRuW,SAAYiF,EAAgB,IAAK,kBACjChF,YAAe,SAAU9U,GACrB,GAAM8C,IACF2J,IAAKzM,EAAK,GAAGyM,IAEjB3J,GAAI,SAAW9C,EAAK,GAAGmD,OACvBL,EAAI+I,SAGJ,KAAK,GADCmP,GAAUhb,EAAK,GAAG6L,OACfoP,EAAK,EAAGA,EAAKD,EAAQva,OAAQwa,IAClCzB,EAAS1W,EAAKkY,EAAQC,GAE1B,OAAOnY,MAIXxE,KAAQ,eACRuW,SAAYkF,EAAmB,IAAK,qBACpCjF,YAAe,SAAU9U,GACrB,OAAQgB,KAAM,SAAUhB,KAAMA,EAAK,OAIvC1B,KAAQ,iBACRuW,SAAYmF,EAAqB,IAAK,sBACtClF,YAAe,SAAU9U,GACrB,OAAQgB,KAAM,WAAYhB,KAAMA,EAAK,OAIzC1B,KAAQ,gBACRuW,SAAYoF,EAAoB,IAAK,sBACrCnF,YAAe,SAAU9U,GACrB,OAAQgB,KAAM,UAAWhB,KAAMA,EAAK,OAIxC1B,KAAQ,SACRuW,SAAY,aAAc,IAAKwF,EAAI,IAAK,gBACxCvF,YAAe,SAAU9U,GACrB,OAAQgB,KAAM,SAAU4E,IAAK5F,EAAK,GAAIK,MAAOL,EAAK,OAGzD1B,KAAQ,uBAAwBuW,aAChCvW,KAAQ,uCAAwCuW,SAAY,eAC5DvW,KAAQ,uCAAwCuW,SAAY,mBAEzDvW,KAAQ,uBACRuW,SAAY,uBAAwB,wCACpCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,gBACRuW,SAAY4F,EAAS,uBAAwBC,GAC7C5F,YAAe,SAAU9U,GACrB,GAAMkb,KACN,KAAK,GAAMvd,KAAKqC,GAAK,GAAIkb,EAAIra,KAAKb,EAAK,GAAGrC,GAAG,GAC7C,QAAQqD,KAAM,SAAUhB,KAAMkb,MAIrC5c,KAAQ,uBAAwBuW,aAChCvW,KAAQ,uCAAwCuW,SAAY,mBAC5DvW,KAAQ,uCAAwCuW,SAAY,yBAC5DvW,KAAQ,uCAAwCuW,SAAY,mBAEzDvW,KAAQ,uBACRuW,SAAY,uBAAwB,wCACpCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,gBACRuW,SAAY8F,EAAW,uBAAwBA,GAC/C7F,YAAe,SAAU9U,GACrB,GAAMmb,KACN,KAAK,GAAMxd,KAAKqC,GAAK,GAAImb,EAAIta,KAAKb,EAAK,GAAGrC,GAAG,GAC7C,QAAQqD,KAAM,eAAgBhB,KAAMmb,MAG3C7c,KAAQ,gBAAiBuW,SAAYyF,EAAKK,KAC1Crc,KAAQ,sCAAuCuW,SAAYgF,KAC3Dvb,KAAQ,sCAAuCuW,SAAYiF,KAC3Dxb,KAAQ,sCAAuCuW,SAAYkF,KAC3Dzb,KAAQ,sCAAuCuW,SAAYmF,KAC3D1b,KAAQ,sCAAuCuW,SAAYoF,KAC3D3b,KAAQ,sCAAuCuW,SAAYqF,KAC3D5b,KAAQ,sCAAuCuW,SAAYsF,KAC3D7b,KAAQ,sCAAuCuW,SAAYuF,KAC3D9b,KAAQ,sCAAuCuW,SAAYwF,KAC3D/b,KAAQ,sCAAuCuW,SAAYyF,KAC3Dhc,KAAQ,sCAAuCuW,SAAY0F,KAC3Djc,KAAQ,sCAAuCuW,SAAY2F,KAC3Dlc,KAAQ,sCAAuCuW,SAAY+F,KAC3Dtc,KAAQ,sBAAuBuW,SAAY,yCAC3CvW,KAAQ,oBAAqBuW,SAAY,oBAEtCvW,KAAQ,oBACRuW,SAAY,oBAAqB,kBACjCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,aAAcuW,SAAY,qBAAsBC,YAAe,SAAU9U,GACjF,MAAO0Z,GAAW1Z,EAAK,IAAIgI,iBAG9B1J,KAAQ,sCAAuCuW,aAE5CvW,KAAQ,sDACRuW,SAAY,IAAKuF,EAAO,IAAK,0BAG7B9b,KAAQ,sCACRuW,SAAY,sCAAuC,uDACnDC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,+BACRuW,SAAY,uBAAwB,yCAEvCvW,KAAQ,+BAAgCuW,SAAY,mBAEjDvW,KAAQ,eACRuW,SAAY,gCACZC,YAAe,SAAU9U,GAErB,GAAMmF,GAAQnF,EAAK,EACnB,IAAqB,IAAjBmF,EAAM1E,OAAc,CAEpB,GAAM2a,KACNA,GAAOva,KAAKsE,EAAM,GAClB,KAAK,GAAIxH,GAAI,EAAGA,EAAIwH,EAAM,GAAG1E,OAAQ9C,IAAKyd,EAAOva,KAAKsE,EAAM,GAAGxH,GAAG,GAClE,QAAQqD,KAAM,sBAAuBhB,KAAMob,GACxC,GAAsB,WAAlBjW,EAAM,GAAGnE,KAChB,OAAQA,KAAM,sBAAuBhB,KAAMmF,EAAM,GAAGnF,KAEnD,MAAM,IAAIR,OAAM,kCAAoCC,KAAKC,UAAUyF,EAAM,QAGrF7G,KAAQ,uCAAwCuW,SAAY,mBAC5DvW,KAAQ,uCAAwCuW,SAAY,gBAC5DvW,KAAQ,uCAAwCuW,SAAYsF,KAEzD7b,KAAQ,uBACRuW,SAAY,wCACZC,YAAe,SAAU9U,GAErB,MAAIA,GAAK,GAAG,GAAGgB,KAAgChB,EAAK,GAAG,MAM9D1B,KAAQ,oCAAqCuW,aAE1CvW,KAAQ,oCACRuW,SAAY,oCAAqC,kBACjDC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,6BACRuW,SAAY,uBAAwB,uCAGpCvW,KAAQ,aACRuW,SAAY,8BACZC,YAAe,SAAU9U,GAErB,OAAQkD,UADIlD,EAAK,GAAG,GAAK0Z,EAAW1Z,EAAK,GAAG,QAInD1B,KAAQ,iCAAkCuW,SAAYyF,KACtDhc,KAAQ,iCAAkCuW,SAAY0F,KACtDjc,KAAQ,iCAAkCuW,SAAY2F,KACtDlc,KAAQ,iCAAkCuW,SAAYgF,KACtDvb,KAAQ,iCAAkCuW,SAAYsF,KACtD7b,KAAQ,iCAAkCuW,SAAYiF,KACtDxb,KAAQ,iCAAkCuW,SAAYkF,KACtDzb,KAAQ,iCAAkCuW,SAAYmF,KACtD1b,KAAQ,iCAAkCuW,SAAYoF,KAEnD3b,KAAQ,iBACRuW,SAAY,kCACZC,YAAe,SAAU9U,GACrB,GAA0B,gBAAfA,GAAK,GAAG,GAAiB,CAChC,IAAKA,EAAK,GAAG,GAAGmD,OAAQ,KAAM,IAAI3D,OAAM,YAAcQ,EAAK,GAAK,2BAChE,OAAOA,GAAK,GAAG,GAAGmD,OAElB,GAA6B,gBAAfnD,GAAK,GAAG,IAAyC,gBAAfA,GAAK,GAAG,GACpD,KAAM,IAAIR,OAAM,YAAcQ,EAAK,GAAG,GAAK,kBAC/C,OAAOA,GAAK,GAAG,MAI1B1B,KAAQ,uCAAwCuW,SAAYyF,KAC5Dhc,KAAQ,uCAAwCuW,SAAY0F,KAC5Djc,KAAQ,uCAAwCuW,SAAY2F,KAC5Dlc,KAAQ,uCAAwCuW,SAAYgF,KAC5Dvb,KAAQ,uCAAwCuW,SAAYiF,KAC5Dxb,KAAQ,uCAAwCuW,SAAYkF,KAC5Dzb,KAAQ,uCAAwCuW,SAAYmF,KAC5D1b,KAAQ,uCAAwCuW,SAAYoF,KAEzD3b,KAAQ,uBACRuW,SAAY,wCACZC,YAAe,SAAU9U,GACrB,GAA0B,gBAAfA,GAAK,GAAG,GAAiB,CAChC,IAAKA,EAAK,GAAG,GAAGmD,OAAQ,KAAM,IAAI3D,OAAM,YAAcQ,EAAK,GAAK,2BAChE,OAAOA,GAAK,GAAG,GAAGmD,OAElB,GAA6B,gBAAfnD,GAAK,GAAG,IAAyC,gBAAfA,GAAK,GAAG,GACpD,KAAM,IAAIR,OAAM,YAAcQ,EAAK,GAAG,GAAK,kBAC/C,OAAOA,GAAK,GAAG,MAI1B1B,KAAQ,4BAA6BuW,SAAYyF,KACjDhc,KAAQ,4BAA6BuW,SAAY0F,KACjDjc,KAAQ,4BAA6BuW,SAAY2F,KACjDlc,KAAQ,4BAA6BuW,SAAYgF,KACjDvb,KAAQ,4BAA6BuW,SAAY8F,KACjDrc,KAAQ,4BAA6BuW,SAAYqF,KACjD5b,KAAQ,4BAA6BuW,SAAYsF,KACjD7b,KAAQ,4BAA6BuW,SAAY+F,KACjDtc,KAAQ,4BAA6BuW,SAAYiF,KACjDxb,KAAQ,4BAA6BuW,SAAYkF,KACjDzb,KAAQ,4BAA6BuW,SAAYmF,KACjD1b,KAAQ,4BAA6BuW,SAAYoF,KACjD3b,KAAQ,4BAA6BuW,SAAYuF,KACjD9b,KAAQ,4BAA6BuW,SAAYwF,KAE9C/b,KAAQ,YACRuW,SAAY,6BACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,MAGtB1B,KAAQ,8BAA+BuW,SAAYyF,KACnDhc,KAAQ,8BAA+BuW,SAAYgF,KACnDvb,KAAQ,8BAA+BuW,SAAY8F,KACnDrc,KAAQ,8BAA+BuW,SAAYqF,KACnD5b,KAAQ,8BAA+BuW,SAAYsF,KACnD7b,KAAQ,8BAA+BuW,SAAY+F,KACnDtc,KAAQ,8BAA+BuW,SAAYiF,KACnDxb,KAAQ,8BAA+BuW,SAAYkF,KACnDzb,KAAQ,8BAA+BuW,SAAYmF,KACnD1b,KAAQ,8BAA+BuW,SAAYoF,KACnD3b,KAAQ,8BAA+BuW,SAAYuF,KACnD9b,KAAQ,8BAA+BuW,SAAYwF,KAEhD/b,KAAQ,cACRuW,SAAY,+BACZC,YAAe,SAAU9U,GACrB,MAAOA,GAAK,GAAG,MAGtB1B,KAAQ,mCAAoCuW,SAAY,mBACxDvW,KAAQ,mCAAoCuW,SAAY,oBACxDvW,KAAQ,mCAAoCuW,SAAY,mCACxDvW,KAAQ,mCAAoCuW,SAAY,2BACxDvW,KAAQ,mBAAoBuW,SAAY,sCACxCvW,KAAQ,mCAAoCuW,SAAY,mBACxDvW,KAAQ,mCAAoCuW,SAAY,oBACxDvW,KAAQ,mCAAoCuW,SAAY,mCACxDvW,KAAQ,mCAAoCuW,SAAY,2BAErDvW,KAAQ,mBACRuW,SAAY,mBAAoB,oCAChCC,YAAe,SAAiBzW,GAC5B,MAAOA,GAAE,GAAG6F,QAAQ7F,EAAE,QAI1BC,KAAQ,YAAauW,SAAY,oBAAqBC,YAAe,SAAU9U,GAG/E,IAAK,GADCqJ,MACGgS,EAAK,EAAGA,EAAKrb,EAAK,GAAGS,OAAQ4a,IAAMhS,EAAOxI,KAAKb,EAAK,GAAGqb,GAAI,GACpE,OAAOhS,MAIP/K,KAAQ,iBAAkBuW,SAAYyF,EAAKA,GAAMxF,YAAe,WAChE,MAAO,QAIPxW,KAAQ,gBAAiBuW,SAAYyF,EAAK,cAAexF,YAAe,SAAU9U,GAClF,OAAQgB,KAAM,eAAgBhB,KAAMA,EAAK,OAIzC1B,KAAQ,gCACRuW,SAAYyF,EAAK,yBACjBxF,YAAe,SAAU9U,GACrB,MAAOA,MAGd1B,KAAQ,wCAAyCuW,SAAYgF,KAC7Dvb,KAAQ,wCAAyCuW,SAAYqF,KAC7D5b,KAAQ,wCAAyCuW,SAAYsF,KAC7D7b,KAAQ,wCAAyCuW,SAAYuF,KAC7D9b,KAAQ,wCAAyCuW,SAAYwF,KAC7D/b,KAAQ,wCAAyCuW,SAAY0F,KAC7Djc,KAAQ,wCAAyCuW,SAAY2F,KAC7Dlc,KAAQ,wCAAyCuW,SAAY4F,KAC7Dnc,KAAQ,wCAAyCuW,SAAY6F,KAC7Dpc,KAAQ,wCAAyCuW,SAAY8F,KAC7Drc,KAAQ,wCAAyCuW,SAAY+F,KAE1Dtc,KAAQ,wBACRuW,SAAY,yCACZC,YAAe,SAAU9U,GAErB,MAAOA,GAAK,GAAG,MAIzBiO,YAAa,StB2zDb,SAAU1Q,EAAQD,EAASQ,GAEjC,YAEAW,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,GuB35EtD,IAAAib,GAAAxd,EAAA,IACAyd,EAAAzd,EAAA,IACA0d,EAAA1d,EAAA,IACA2d,EAAA3d,EAAA,IACA4d,EAAA5d,EAAA,IAEAqa,EAAA,WAKI,QAAAA,GAAYhV,GACRvF,KAAK2B,IAAM4D,EACXvF,KAAK+d,IAAMxY,EAAO1C,OAClB7C,KAAKge,IAAM,EA8HnB,MA3HIzD,GAAAjZ,UAAA2c,6BAAA,SAA6BC,GAIzB,IAAK,GADCC,MACGpe,EAAIC,KAAKge,IAAKje,EAAIC,KAAK+d,IAAM,EAAGhe,IAAK,CAE1C,GADAC,KAAKge,IAAMje,EACe,MAAtBC,KAAK2B,IAAIoI,OAAOhK,IAAcC,KAAK2B,IAAIoI,OAAOhK,EAAI,GAAGwH,MAAM2W,GAC3Dne,IACAC,KAAKge,IAAMje,MACR,IAAIC,KAAK2B,IAAIoI,OAAOhK,GAAGwH,MAAM2W,GAChC,KAEJC,GAAMlb,KAAKjD,KAAK2B,IAAIoI,OAAOhK,IAE/B,MAAOoe,GAAMnZ,KAAK,KAEtBuV,EAAAjZ,UAAAmP,WAAA,WAGI,IAFA,GACI2N,GADE3S,KAEC2S,EAAYpe,KAAKqe,iBACpB5S,EAAOxI,KAAKmb,EAChB,OAAO3S,IAGX8O,EAAAjZ,UAAA+c,cAAA,WACI,KAAIre,KAAKge,KAAOhe,KAAK2B,IAAIkB,QAAzB,CAGA,GAAMyb,GAAsBte,KAAK2B,IAAIoI,OAAO/J,KAAKge,IAEjD,QAAI,EAAAL,EAAA/K,6BAA4B0L,GACrBte,KAAKue,iBACP,EAAAb,EAAAhM,eAAc4M,GACZte,KAAKwe,gBAAgBF,IACrB,EAAAV,EAAAzK,OAAMmL,GACNte,KAAKye,iBAAiBH,GAEtBte,KAAK0e,gBAeZnE,EAAAjZ,UAAAod,YAAR,WAII,IAAK,GAFCP,MACAQ,EAAO3e,KAAKge,IACTje,EAAI4e,EAAM5e,EAAIC,KAAK+d,IAAM,EAAGhe,IAAK,CACtCC,KAAKge,IAAMje,CAGX,IAAM6e,GAAU5e,KAAK2B,IAAIoI,OAAOhK,EAChC,MAAK,EAAA8d,EAAAgB,UAASD,GACV,KAMAT,GAAMlb,KAAK2b,GAInB,OAAO,EAAAf,EAAAiB,YAAWX,EAAMnZ,KAAK,IAAI+Z,SAG7BxE,EAAAjZ,UAAAmd,iBAAR,SAAyBO,GAIrB,IAAK,GAHCC,IAAuBD,GAEvBE,EAAUlf,KAAKge,IAAM,EAClBmB,EAASD,EAASC,EAASnf,KAAK+d,IAAM,EAAGoB,IAAU,CACxDnf,KAAKge,IAAMmB,CAEX,IAAMC,GAAUpf,KAAK2B,IAAIoI,OAAOoV,EAChC,MAAI,EAAAvB,EAAAzK,OAAMiM,GAGN,KAFAH,GAAKhc,KAAKmc,GAKlB,GAAMC,GAAwBJ,EAAKja,KAAK,GAExC,IAAgB,MAAZia,EAAK,GACL,OAAO,EAAArB,EAAA1K,WAAUmM,EAEjB,IAAMnK,GAAS8G,OAAOsD,SAASD,EAC/B,OAAOrD,QAAOuD,SAASrK,GAAUA,GAAS,EAAA0I,EAAA1K,WAAUmM,IAIpD9E,EAAAjZ,UAAAkd,gBAAR,SAAwBQ,GAEpB,GADAhf,KAAKge,MACW,MAAZgB,EAAiB,CACjB,GAAM5b,GAAOpD,KAAKie,6BAA6B,KAAKc,OAAO3U,aAC3D,QAAI,EAAA0T,EAAA0B,WAAUpc,IACH,EAAAsa,EAAAjM,UAASqM,EAAA2B,SAASrc,GAAOA,IAEzB,EAAAsa,EAAAjM,UAAS,OAAQrO,GAEhC,MAAO4b,IAGHzE,EAAAjZ,UAAAid,cAAR,WAEI,IADA,GAAMJ,MACCne,KAAKge,IAAMhe,KAAK+d,IAAM,GAAG,CAC5B,GAAMvd,GAAIR,KAAK2B,IAAIoI,OAAO/J,KAAKge,IAE/B,MAAI,EAAAL,EAAA/K,6BAA4BpS,GAGzB,KAFH2d,GAAMlb,KAAKzC,GACXR,KAAKge,MAGb,OAAO,EAAAL,EAAAnL,eAAc2L,EAAMnZ,KAAK,MAExCuV,IvB63EA7a,GAAQ8Q,QAAU+J,GAKZ,SAAU5a,EAAQD,EAASQ,GAEjC,YwBtgFA,SAAgB4e,GAAWvZ,GACvB,OACInC,KAAM,KACNmC,OAAMA,GAId,QAAgBma,GAAUna,GACtB,MAAuB,OAAhBA,EAAOnC,MAA0C,gBAAlBmC,GAAOA,OAGjD,QAAgBsZ,GAASre,GACrB,SAAS,EAAAkd,EAAAhM,eAAclR,KAAM,EAAAod,EAAAzK,OAAM3S,KAAM,EAAAmd,EAAA/K,6BAA4BpS,IxB4/EzEK,OAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQmf,SAAWnf,EAAQggB,UAAYhgB,EAAQof,eAAa,EwBnhF5D,IAAApB,GAAAxd,EAAA,IAEAyd,EAAAzd,EAAA,IACA0d,EAAA1d,EAAA,GAOAR,GAAAof,aAOApf,EAAAggB,YAIAhgB,EAAAmf,YxBqhFM,SAAUlf,EAAQD,EAASQ,GAEjC,YAEAW,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO,IACtD/C,EAAQ8f,UAAY9f,EAAQ+f,aAAW,GyB/iF1B/f,EAAA+f,UACTla,OAAQ,UACRoa,SAAU,YACVC,QAAS,WACTC,IAAK,OAKF,IAAML,GAAY,SAAUhf,GAC/B,MAAOd,GAAA+f,SAASle,eAAef,GADtBd,GAAA8f,UAASA,GzBqjFhB,SAAU7f,EAAQD,EAASQ,GAEjC,YAEAW,QAAOC,eAAepB,EAAS,cAAgB+C,OAAO","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 17);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.flattenMyArray = exports.isString = exports.isNumber = exports.isArray = exports.mustBeArray = exports.mustBeDefined = exports.mustBeString = void 0;\r\nfunction mustBeString(str, o) {\r\n    if (typeof str !== \"string\")\r\n        throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\r\n    return str;\r\n}\r\nexports.mustBeString = mustBeString;\r\nfunction mustBeDefined(t, o) {\r\n    if (t === undefined)\r\n        throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\r\n    return t;\r\n}\r\nexports.mustBeDefined = mustBeDefined;\r\nfunction mustBeArray(str, o) {\r\n    if (!isArray(str))\r\n        throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\r\n    return str;\r\n}\r\nexports.mustBeArray = mustBeArray;\r\nfunction isArray(data) {\r\n    return !!data && data.constructor === Array;\r\n}\r\nexports.isArray = isArray;\r\nfunction isNumber(data) {\r\n    return typeof data === \"number\";\r\n}\r\nexports.isNumber = isNumber;\r\nfunction isString(data) {\r\n    return typeof data === \"string\";\r\n}\r\nexports.isString = isString;\r\nvar flattenMyArray = function (arr, result) {\r\n    if (!result)\r\n        result = [];\r\n    for (var i = 0, length = arr.length; i < length; i++) {\r\n        var value = arr[i];\r\n        if (Array.isArray(value)) {\r\n            for (var i_1 = 0, length_1 = value.length; i_1 < length_1; i_1++) {\r\n                var value2 = value[i_1];\r\n                if (Array.isArray(value2)) {\r\n                    (0, exports.flattenMyArray)(value2, result);\r\n                }\r\n                else {\r\n                    result.push(value2);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result.push(value);\r\n        }\r\n    }\r\n    return result;\r\n};\r\nexports.flattenMyArray = flattenMyArray;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isQuotedString = exports.isOuterQuotedString = exports.OuterQuotedString = exports.QuotedString = void 0;\r\nvar BibStringComponent_1 = __webpack_require__(4);\r\nvar QuotedString = (function (_super) {\r\n    __extends(QuotedString, _super);\r\n    function QuotedString(braceDepth, data) {\r\n        return _super.call(this, \"quotedstring\", braceDepth, data) || this;\r\n    }\r\n    return QuotedString;\r\n}(BibStringComponent_1.BibStringComponent));\r\nexports.QuotedString = QuotedString;\r\nvar OuterQuotedString = (function (_super) {\r\n    __extends(OuterQuotedString, _super);\r\n    function OuterQuotedString(data) {\r\n        return _super.call(this, \"quotedstringwrapper\", data) || this;\r\n    }\r\n    return OuterQuotedString;\r\n}(BibStringComponent_1.BibOuterStringComponent));\r\nexports.OuterQuotedString = OuterQuotedString;\r\nfunction isOuterQuotedString(x) {\r\n    return x.type === \"quotedstringwrapper\";\r\n}\r\nexports.isOuterQuotedString = isOuterQuotedString;\r\nfunction isQuotedString(x) {\r\n    return x.type === \"quotedstring\";\r\n}\r\nexports.isQuotedString = isQuotedString;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isBracedString = exports.isOuterBracedString = exports.OuterBracedString = exports.BracedString = void 0;\r\nvar BibStringComponent_1 = __webpack_require__(4);\r\nvar BracedString = (function (_super) {\r\n    __extends(BracedString, _super);\r\n    function BracedString(braceDepth, data) {\r\n        var _this = _super.call(this, \"bracedstring\", braceDepth, data) || this;\r\n        _this.isSpecialCharacter = braceDepth === 0 && data[0] === \"\\\\\";\r\n        return _this;\r\n    }\r\n    return BracedString;\r\n}(BibStringComponent_1.BibStringComponent));\r\nexports.BracedString = BracedString;\r\nvar OuterBracedString = (function (_super) {\r\n    __extends(OuterBracedString, _super);\r\n    function OuterBracedString(data) {\r\n        return _super.call(this, \"bracedstringwrapper\", data) || this;\r\n    }\r\n    return OuterBracedString;\r\n}(BibStringComponent_1.BibOuterStringComponent));\r\nexports.OuterBracedString = OuterBracedString;\r\nfunction isOuterBracedString(x) {\r\n    return x.type === \"bracedstringwrapper\";\r\n}\r\nexports.isOuterBracedString = isOuterBracedString;\r\nfunction isBracedString(x) {\r\n    return x.type === \"bracedstring\";\r\n}\r\nexports.isBracedString = isBracedString;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.splitOnPattern = exports.splitOnComma = exports.splitOnAnd = exports.globContiguousStrings = exports.flattenQuotedStrings = exports.toStringBibStringData = exports.toStringBibStringDatum = exports.parseStringComponent = exports.joinContiguousSimpleStrings = exports.isContiguousSimpleString = exports.isBibStringComponent = void 0;\r\nvar StringRef_1 = __webpack_require__(5);\r\nvar BracedString_1 = __webpack_require__(2);\r\nvar QuotedString_1 = __webpack_require__(1);\r\nvar util_1 = __webpack_require__(0);\r\nfunction isBibStringComponent(x) {\r\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\r\n}\r\nexports.isBibStringComponent = isBibStringComponent;\r\nfunction isContiguousSimpleString(x) {\r\n    return x.type === \"ContiguousSimpleString\" && (0, util_1.isArray)(x.data);\r\n}\r\nexports.isContiguousSimpleString = isContiguousSimpleString;\r\nfunction joinContiguousSimpleStrings(x) {\r\n    return x.data.join(\"\");\r\n}\r\nexports.joinContiguousSimpleStrings = joinContiguousSimpleStrings;\r\nfunction parseStringComponent(braceDepth, obj) {\r\n    if ((0, util_1.isNumber)(obj) || (0, util_1.isString)(obj))\r\n        return obj;\r\n    if ((0, StringRef_1.isStringRef)(obj))\r\n        return new StringRef_1.StringRef(0, obj.stringref);\r\n    switch ((0, util_1.mustBeString)(obj.type, obj)) {\r\n        case \"id\":\r\n        case \"ws\":\r\n        case \"number\":\r\n            return (0, util_1.mustBeString)(obj.string);\r\n        case \"bracedstring\":\r\n        case \"braced\":\r\n            if (!(0, util_1.isArray)(obj.data)) {\r\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\r\n            }\r\n            return new BracedString_1.BracedString(braceDepth, (0, util_1.flattenMyArray)(obj.data).map(function (e) { return parseStringComponent(braceDepth + 1, e); }));\r\n        case \"quotedstring\":\r\n            if (!(0, util_1.isArray)(obj.data)) {\r\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\r\n            }\r\n            var flattened = (0, util_1.flattenMyArray)(obj.data);\r\n            return new QuotedString_1.QuotedString(braceDepth, flattened.map(function (e) { return parseStringComponent(braceDepth, e); }));\r\n        default:\r\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\r\n    }\r\n}\r\nexports.parseStringComponent = parseStringComponent;\r\nfunction toStringBibStringDatum(data) {\r\n    if ((0, util_1.isString)(data))\r\n        return data;\r\n    if ((0, util_1.isNumber)(data))\r\n        return data + \"\";\r\n    if ((0, BracedString_1.isBracedString)(data)\r\n        || (0, QuotedString_1.isQuotedString)(data)\r\n        || (0, QuotedString_1.isOuterQuotedString)(data)\r\n        || (0, BracedString_1.isOuterBracedString)(data))\r\n        return toStringBibStringData(data.data);\r\n    throw new Error(JSON.stringify(data));\r\n}\r\nexports.toStringBibStringDatum = toStringBibStringDatum;\r\nfunction toStringBibStringData(data) {\r\n    return data.map(toStringBibStringDatum).join(\"\");\r\n}\r\nexports.toStringBibStringData = toStringBibStringData;\r\nfunction flattenQuotedStrings(data, hideQuotes) {\r\n    var result = [];\r\n    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\r\n        var datum = data_1[_i];\r\n        var flattenned = flattenQuotedString(datum, hideQuotes);\r\n        if ((0, util_1.isArray)(flattenned)) {\r\n            result = result.concat(flattenned);\r\n        }\r\n        else {\r\n            result.push(flattenned);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.flattenQuotedStrings = flattenQuotedStrings;\r\nvar doubleQuotes = [\"\\\"\"];\r\nfunction flattenQuotedString(data, hideQuotes) {\r\n    if ((0, BracedString_1.isBracedString)(data))\r\n        return data;\r\n    if ((0, QuotedString_1.isQuotedString)(data)) {\r\n        var flattenedQuotedString = flattenQuotedStrings(data.data, true);\r\n        if ((0, util_1.isArray)(flattenedQuotedString)) {\r\n            return hideQuotes\r\n                ? flattenedQuotedString\r\n                : doubleQuotes.concat(flattenedQuotedString).concat(doubleQuotes);\r\n        }\r\n        else if (hideQuotes)\r\n            return flattenedQuotedString;\r\n        else\r\n            return [\"\\\"\", flattenedQuotedString, \"\\\"\"];\r\n    }\r\n    if ((0, QuotedString_1.isOuterQuotedString)(data))\r\n        return flattenQuotedStrings(data.data, true);\r\n    if ((0, BracedString_1.isOuterBracedString)(data))\r\n        return flattenQuotedStrings(data.data, false);\r\n    if ((0, util_1.isString)(data) || (0, util_1.isNumber)(data))\r\n        return data;\r\n    if ((0, StringRef_1.isStringRef)(data))\r\n        throw new Error(\"StringRef should be resolved at this point!\");\r\n    else\r\n        throw new Error();\r\n}\r\nfunction globContiguousStrings(data) {\r\n    var result = [];\r\n    for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {\r\n        var element = data_2[_i];\r\n        if ((0, util_1.isString)(element) || (0, util_1.isNumber)(element)) {\r\n            if (result.length <= 0) {\r\n                var contiguousSimpleString = {\r\n                    type: \"ContiguousSimpleString\",\r\n                    data: [element]\r\n                };\r\n                result.push(contiguousSimpleString);\r\n            }\r\n            else {\r\n                var lastElement = result[result.length - 1];\r\n                if (isContiguousSimpleString(lastElement)) {\r\n                    lastElement.data.push(element);\r\n                }\r\n                else {\r\n                    var contiguousSimpleString = {\r\n                        type: \"ContiguousSimpleString\",\r\n                        data: [element]\r\n                    };\r\n                    result.push(contiguousSimpleString);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result.push(element);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.globContiguousStrings = globContiguousStrings;\r\nfunction splitOnAnd(data) {\r\n    return splitOnPattern(data, /\\s+and\\s+/g);\r\n}\r\nexports.splitOnAnd = splitOnAnd;\r\nfunction splitOnComma(data, limit) {\r\n    if (limit === void 0) { limit = 2; }\r\n    return splitOnPattern(data, /\\s*,\\s*/g, limit);\r\n}\r\nexports.splitOnComma = splitOnComma;\r\nfunction splitOnPattern(data, pattern, stopAfter) {\r\n    var splitted = [];\r\n    var buffer = [];\r\n    for (var _i = 0, data_3 = data; _i < data_3.length; _i++) {\r\n        var datum = data_3[_i];\r\n        if ((0, util_1.isString)(datum) && (stopAfter === undefined || stopAfter > 0)) {\r\n            var match = pattern.exec(datum);\r\n            var end = 0;\r\n            if (match) {\r\n                do {\r\n                    var prevEnd = end;\r\n                    end = match.index + match[0].length;\r\n                    buffer.push(datum.substring(prevEnd, match.index));\r\n                    if (stopAfter === undefined || stopAfter > 0) {\r\n                        splitted.push(buffer);\r\n                        buffer = [];\r\n                        if (stopAfter !== undefined && stopAfter > 0)\r\n                            stopAfter--;\r\n                    }\r\n                    if (stopAfter === undefined || stopAfter > 0)\r\n                        match = pattern.exec(datum);\r\n                    else\r\n                        match = undefined;\r\n                } while (match);\r\n                if (end > 0 && end < datum.length)\r\n                    buffer.push(datum.substring(end));\r\n            }\r\n            else {\r\n                buffer.push(datum);\r\n            }\r\n        }\r\n        else\r\n            buffer.push(datum);\r\n    }\r\n    if (buffer.length > 0)\r\n        splitted.push(buffer);\r\n    return splitted;\r\n}\r\nexports.splitOnPattern = splitOnPattern;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BibOuterStringComponent = exports.stringifyDatum = exports.BibStringComponent = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nvar BibStringComponent = (function () {\r\n    function BibStringComponent(type, braceDepth, data) {\r\n        this.type = type;\r\n        this.braceDepth = braceDepth;\r\n        this.data = data;\r\n    }\r\n    BibStringComponent.prototype.stringify = function () {\r\n        return this.data.map(stringifyDatum).join(\"\");\r\n    };\r\n    return BibStringComponent;\r\n}());\r\nexports.BibStringComponent = BibStringComponent;\r\nfunction isBibStringComponent(x) {\r\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\r\n}\r\nfunction stringifyDatum(datum) {\r\n    if ((0, util_1.isString)(datum))\r\n        return datum;\r\n    if ((0, util_1.isNumber)(datum))\r\n        return datum.toString();\r\n    if (isBibStringComponent(datum))\r\n        return datum.stringify();\r\n    else\r\n        throw new Error(\"Unexpected state\");\r\n}\r\nexports.stringifyDatum = stringifyDatum;\r\nvar BibOuterStringComponent = (function (_super) {\r\n    __extends(BibOuterStringComponent, _super);\r\n    function BibOuterStringComponent(type, data) {\r\n        return _super.call(this, type, 0, data) || this;\r\n    }\r\n    return BibOuterStringComponent;\r\n}(BibStringComponent));\r\nexports.BibOuterStringComponent = BibOuterStringComponent;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isStringRef = exports.StringRef = void 0;\r\nvar StringRef = (function () {\r\n    function StringRef(braceDepth, stringref) {\r\n        this.braceDepth = braceDepth;\r\n        this.stringref = stringref;\r\n    }\r\n    return StringRef;\r\n}());\r\nexports.StringRef = StringRef;\r\nfunction isStringRef(stringref) {\r\n    return typeof stringref.stringref === \"string\";\r\n}\r\nexports.isStringRef = isStringRef;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.normalizeFieldValue = exports.parseFieldValue = exports.newKeyVal = exports.isKeyVal = void 0;\r\nvar BracedString_1 = __webpack_require__(2);\r\nvar QuotedString_1 = __webpack_require__(1);\r\nvar util_1 = __webpack_require__(0);\r\nvar bib_string_utils_1 = __webpack_require__(3);\r\nfunction isKeyVal(data) {\r\n    return typeof data.key === \"string\"\r\n        && data.value !== undefined;\r\n}\r\nexports.isKeyVal = isKeyVal;\r\nfunction newKeyVal(data) {\r\n    if (isKeyVal(data)) {\r\n        return {\r\n            key: data.key,\r\n            value: parseFieldValue(data.value),\r\n        };\r\n    }\r\n    else {\r\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\r\n    }\r\n}\r\nexports.newKeyVal = newKeyVal;\r\nfunction parseFieldValue(value) {\r\n    if ((0, util_1.isNumber)(value)) {\r\n        return value;\r\n    }\r\n    var data = (0, util_1.mustBeArray)(value.data);\r\n    switch (value.type) {\r\n        case \"quotedstringwrapper\":\r\n            if (data.length === 1 && (0, util_1.isNumber)(data[0]))\r\n                return data[0];\r\n            return new QuotedString_1.OuterQuotedString(data.map(function (e) { return (0, bib_string_utils_1.parseStringComponent)(0, e); }));\r\n        case \"bracedstringwrapper\":\r\n            return new BracedString_1.OuterBracedString(data.map(function (e) { return (0, bib_string_utils_1.parseStringComponent)(0, e); }));\r\n        default:\r\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\r\n    }\r\n}\r\nexports.parseFieldValue = parseFieldValue;\r\nfunction normalizeFieldValue(field) {\r\n    if (!field)\r\n        return undefined;\r\n    if ((0, util_1.isNumber)(field))\r\n        return field;\r\n    else\r\n        return field.stringify();\r\n}\r\nexports.normalizeFieldValue = normalizeFieldValue;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.copyOuterWithResolvedStringReferences = exports.copyWithResolvedStringReferences = exports.resolveStringReference = exports.resolveStringReferences = exports.resolveStrings = exports.newStringEntry = exports.BibStringEntry = void 0;\r\nvar KeyVal_1 = __webpack_require__(6);\r\nvar StringRef_1 = __webpack_require__(5);\r\nvar QuotedString_1 = __webpack_require__(1);\r\nvar BracedString_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(0);\r\nvar bib_string_utils_1 = __webpack_require__(3);\r\nvar BibStringEntry = (function () {\r\n    function BibStringEntry(key, value) {\r\n        this.type = \"string\";\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    return BibStringEntry;\r\n}());\r\nexports.BibStringEntry = BibStringEntry;\r\nfunction newStringEntry(data) {\r\n    var _a = convertToKeyVal(data), key = _a.key, value = _a.value;\r\n    return new BibStringEntry(key, value);\r\n}\r\nexports.newStringEntry = newStringEntry;\r\nfunction convertToKeyVal(data) {\r\n    if ((0, KeyVal_1.isKeyVal)(data)) {\r\n        return (0, KeyVal_1.newKeyVal)(data);\r\n    }\r\n    else {\r\n        if (data.type !== \"string\") {\r\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\r\n        }\r\n        return convertToKeyVal(data.data);\r\n    }\r\n}\r\nfunction resolveStrings(strings) {\r\n    var resolved = {};\r\n    Object.keys(strings).forEach(function (key) {\r\n        if (!resolved[key])\r\n            resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\r\n    });\r\n    return resolved;\r\n}\r\nexports.resolveStrings = resolveStrings;\r\nfunction resolveStringReferences(o, seenBeforeStack, alreadyResolved, refs) {\r\n    return o.data.map(function (datum) {\r\n        if ((0, util_1.isString)(datum) || (0, util_1.isNumber)(datum))\r\n            return datum;\r\n        else if ((0, StringRef_1.isStringRef)(datum))\r\n            return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);\r\n        else if ((0, bib_string_utils_1.isBibStringComponent)(datum))\r\n            return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);\r\n        else\r\n            throw new Error();\r\n    });\r\n}\r\nexports.resolveStringReferences = resolveStringReferences;\r\nfunction resolveStringReference(seenBeforeStack, alreadyResolved, refs, data) {\r\n    if ((0, util_1.isNumber)(data)) {\r\n        return data;\r\n    }\r\n    else if ((0, BracedString_1.isOuterBracedString)(data) || (0, QuotedString_1.isOuterQuotedString)(data)) {\r\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\r\n    }\r\n    if ((0, StringRef_1.isStringRef)(data)) {\r\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\r\n    }\r\n    return data;\r\n}\r\nexports.resolveStringReference = resolveStringReference;\r\nfunction resolveStringRef(seenBeforeStack, refs, data, alreadyResolved) {\r\n    var _a;\r\n    var refName = data.stringref;\r\n    if (seenBeforeStack[refName])\r\n        throw new Error(\"Cycle detected: \" + refName);\r\n    if (alreadyResolved[refName]) {\r\n        return alreadyResolved[refName];\r\n    }\r\n    if (!refs[refName])\r\n        throw new Error(\"Unresolved reference: \\\"\".concat(data.stringref, \"\\\" (\").concat(JSON.stringify(data), \")\"));\r\n    alreadyResolved[refName] = resolveStringReference(Object.assign({}, seenBeforeStack, (_a = {}, _a[refName] = true, _a)), alreadyResolved, refs, refs[refName]);\r\n    return alreadyResolved[refName];\r\n}\r\nfunction copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\r\n    var newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\r\n    var braceDepth = obj.braceDepth;\r\n    if ((0, QuotedString_1.isQuotedString)(obj))\r\n        return new QuotedString_1.QuotedString(braceDepth, newData);\r\n    if ((0, BracedString_1.isBracedString)(obj))\r\n        return new BracedString_1.BracedString(braceDepth, newData);\r\n    if ((0, QuotedString_1.isOuterQuotedString)(obj))\r\n        return new QuotedString_1.OuterQuotedString(newData);\r\n    if ((0, BracedString_1.isOuterBracedString)(obj))\r\n        return new BracedString_1.OuterBracedString(newData);\r\n    else\r\n        throw new Error();\r\n}\r\nexports.copyWithResolvedStringReferences = copyWithResolvedStringReferences;\r\nfunction copyOuterWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\r\n    var copied = copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\r\n    if (!(0, BracedString_1.isOuterBracedString)(copied) && !(0, QuotedString_1.isOuterQuotedString)(copied))\r\n        throw new Error();\r\n    return copied;\r\n}\r\nexports.copyOuterWithResolvedStringReferences = copyOuterWithResolvedStringReferences;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseAuthorName = exports.AuthorName = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nvar QuotedString_1 = __webpack_require__(1);\r\nvar StringRef_1 = __webpack_require__(5);\r\nvar BracedString_1 = __webpack_require__(2);\r\nvar bib_string_utils_1 = __webpack_require__(3);\r\nfunction word2string(obj) {\r\n    if (typeof obj === \"string\")\r\n        return obj;\r\n    else if (obj.type == \"braced\")\r\n        return word2string(obj.data);\r\n    else if (obj.unicode)\r\n        return obj.unicode;\r\n    else if (obj.string)\r\n        return obj.string;\r\n    else if (obj.constructor == Array)\r\n        return obj.map(word2string).join(\"\");\r\n    else\r\n        throw new Error(\"? \" + JSON.stringify(obj));\r\n}\r\nvar WHITESPACES = /\\s+/g;\r\nvar AuthorName = (function () {\r\n    function AuthorName(firstNames, vons, lastNames, jrs) {\r\n        this.firstNames$ = firstNames;\r\n        this.vons$ = vons;\r\n        this.lastNames$ = lastNames;\r\n        this.jrs$ = jrs;\r\n        this.initials = firstNames.map(getFirstLetter);\r\n        this.firstNames = firstNames.map(bib_string_utils_1.toStringBibStringData);\r\n        this.vons = vons.map(bib_string_utils_1.toStringBibStringData);\r\n        this.lastNames = lastNames.map(bib_string_utils_1.toStringBibStringData);\r\n        this.jrs = jrs.map(bib_string_utils_1.toStringBibStringData);\r\n        this.id = this.firstNames.join(\"-\") + \"-\"\r\n            + this.vons.join(\"-\") + \"-\"\r\n            + this.lastNames.join(\"-\") + \"-\"\r\n            + this.jrs.join(\"-\");\r\n    }\r\n    return AuthorName;\r\n}());\r\nexports.AuthorName = AuthorName;\r\nfunction getFirstLetter(bsd) {\r\n    var asString = (0, bib_string_utils_1.toStringBibStringData)(bsd);\r\n    return asString ? asString.charAt(0) : \"\";\r\n}\r\nfunction isPartOfName(char) {\r\n    return (char === \",\" || char.match(/\\s/));\r\n}\r\nfunction startsWithLowerCaseBSD(authorToken) {\r\n    if (authorToken.length > 0)\r\n        return startsWithLowerCase(authorToken[0]);\r\n    else\r\n        return false;\r\n}\r\nfunction startsWithLowerCase(authorToken) {\r\n    if ((0, util_1.isString)(authorToken)) {\r\n        if (!authorToken)\r\n            return false;\r\n        var ch = authorToken.charAt(0);\r\n        return ch.toLowerCase() === ch && ch.toUpperCase() !== ch;\r\n    }\r\n    if ((0, QuotedString_1.isQuotedString)(authorToken)) {\r\n        if (!authorToken.data || authorToken.data.length <= 0)\r\n            return false;\r\n        return startsWithLowerCase(authorToken.data[0]);\r\n    }\r\n    if ((0, StringRef_1.isStringRef)(authorToken)\r\n        || (0, QuotedString_1.isOuterQuotedString)(authorToken)\r\n        || (0, BracedString_1.isOuterBracedString)(authorToken))\r\n        throw new Error(\"Should not do this test on this type\");\r\n    return false;\r\n}\r\nfunction firstVonLast(outer) {\r\n    var authorTokens = (0, bib_string_utils_1.splitOnPattern)(outer, WHITESPACES);\r\n    var vonStartInclusive = -1;\r\n    var vonEndExclusive = -1;\r\n    var firstNameEndExclusive = -1;\r\n    for (var i = 0; i < authorTokens.length - 1; i++) {\r\n        if (startsWithLowerCaseBSD(authorTokens[i])) {\r\n            if (vonStartInclusive < 0)\r\n                vonStartInclusive = i;\r\n            vonEndExclusive = i + 1;\r\n        }\r\n    }\r\n    if (vonStartInclusive >= 0)\r\n        firstNameEndExclusive = vonStartInclusive;\r\n    else\r\n        firstNameEndExclusive = authorTokens.length - 1;\r\n    var von = vonStartInclusive >= 0 ? getSubStringAsArray(authorTokens, vonStartInclusive, vonEndExclusive) : [];\r\n    var firstName = getSubStringAsArray(authorTokens, 0, firstNameEndExclusive);\r\n    var lastName = getSubStringAsArray(authorTokens, Math.max(vonEndExclusive, firstNameEndExclusive), authorTokens.length);\r\n    return new AuthorName(firstName, von, lastName, []);\r\n}\r\nfunction vonLastFirst(vonLastStr, firstStr) {\r\n    var vonLast = (0, bib_string_utils_1.splitOnPattern)(vonLastStr, WHITESPACES);\r\n    var first = (0, bib_string_utils_1.splitOnPattern)(firstStr, WHITESPACES);\r\n    var vonStartInclusive = -1;\r\n    var vonEndExclusive = -1;\r\n    for (var i = 0; i < vonLast.length - 1; i++)\r\n        if (startsWithLowerCaseBSD(vonLast[i])) {\r\n            if (vonStartInclusive < 0)\r\n                vonStartInclusive = i;\r\n            vonEndExclusive = i + 1;\r\n        }\r\n    var von = vonStartInclusive >= 0 ? getSubStringAsArray(vonLast, 0, vonEndExclusive) : [];\r\n    var firstName = first;\r\n    var lastName = getSubStringAsArray(vonLast, Math.max(vonEndExclusive, 0));\r\n    return new AuthorName(firstName, von, lastName, []);\r\n}\r\nfunction getSubStringAsArray(tokens, startIncl, endExcl) {\r\n    var arr = [];\r\n    for (var i = startIncl; i < (endExcl === undefined ? tokens.length : endExcl); i++) {\r\n        arr.push(tokens[i]);\r\n    }\r\n    return arr;\r\n}\r\nfunction vonLastJrFirst(vonLastStr, jrStr, firstStr) {\r\n    var vonLast = (0, bib_string_utils_1.splitOnPattern)(vonLastStr, WHITESPACES);\r\n    var first = (0, bib_string_utils_1.splitOnPattern)(firstStr, WHITESPACES);\r\n    var jr = (0, bib_string_utils_1.splitOnPattern)(jrStr, WHITESPACES);\r\n    var vonStartInclusive = -1;\r\n    var vonEndExclusive = -1;\r\n    for (var i = 0; i < vonLast.length - 1; i++)\r\n        if (startsWithLowerCaseBSD(vonLast[i])) {\r\n            if (vonStartInclusive < 0)\r\n                vonStartInclusive = i;\r\n            vonEndExclusive = i + 1;\r\n        }\r\n    var von = vonStartInclusive >= 0 ? getSubStringAsArray(vonLast, 0, vonEndExclusive) : [];\r\n    var lastName = getSubStringAsArray(vonLast, Math.max(vonEndExclusive, 0));\r\n    return new AuthorName(first, von, lastName, jr);\r\n}\r\nfunction parseAuthorName(normalizedFieldValue) {\r\n    var partitions = (0, bib_string_utils_1.splitOnComma)(normalizedFieldValue);\r\n    switch (partitions.length) {\r\n        case 1:\r\n            return firstVonLast(partitions[0]);\r\n        case 2:\r\n            return vonLastFirst(mdbsd(partitions[0]), mdbsd(partitions[1]));\r\n        case 3:\r\n            return vonLastJrFirst(mdbsd(partitions[0]), mdbsd(partitions[1]), mdbsd(partitions[2]));\r\n        default:\r\n            throw new Error(\"Could not parse author name: partitioned as \".concat(JSON.stringify(partitions), \" in \").concat(JSON.stringify(normalizedFieldValue)));\r\n    }\r\n}\r\nexports.parseAuthorName = parseAuthorName;\r\nfunction isdbsd(x) {\r\n    return x !== undefined;\r\n}\r\nfunction mdbsd(x) {\r\n    if (isdbsd(x))\r\n        return x;\r\n    else\r\n        throw new Error(\"???????\");\r\n}\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isAuthors = exports.mustBeAuthors = exports.determineAuthorNames$ = exports.Authors = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nvar Author_1 = __webpack_require__(8);\r\nvar QuotedString_1 = __webpack_require__(1);\r\nvar BibStringComponent_1 = __webpack_require__(4);\r\nvar bib_string_utils_1 = __webpack_require__(3);\r\nvar Authors = (function (_super) {\r\n    __extends(Authors, _super);\r\n    function Authors(fieldValue) {\r\n        var _this = this;\r\n        var data = (0, util_1.isNumber)(fieldValue) ? [fieldValue] : fieldValue.data;\r\n        _this = _super.call(this, \"authors\", data) || this;\r\n        var authorNames = determineAuthorNames$(fieldValue);\r\n        _this.authors$ = authorNames.map(function (name) { return parseAuthor(name); });\r\n        return _this;\r\n    }\r\n    return Authors;\r\n}(BibStringComponent_1.BibOuterStringComponent));\r\nexports.Authors = Authors;\r\nfunction parseAuthor(data) {\r\n    return (0, Author_1.parseAuthorName)(data);\r\n}\r\nfunction determineAuthorNames$(data) {\r\n    if ((0, util_1.isNumber)(data)) {\r\n        return determineAuthorNames([data]);\r\n    }\r\n    else {\r\n        return determineAuthorNames(data.data, (0, QuotedString_1.isOuterQuotedString)(data));\r\n    }\r\n}\r\nexports.determineAuthorNames$ = determineAuthorNames$;\r\nfunction determineAuthorNames(data, hideQuotes) {\r\n    var globbed = (0, bib_string_utils_1.globContiguousStrings)((0, bib_string_utils_1.flattenQuotedStrings)(data, hideQuotes));\r\n    var normalizedString = globbed.map(function (e) { return (0, bib_string_utils_1.isContiguousSimpleString)(e) ? (0, bib_string_utils_1.joinContiguousSimpleStrings)(e) : e; });\r\n    return (0, bib_string_utils_1.splitOnAnd)(normalizedString);\r\n}\r\nfunction mustBeAuthors(x) {\r\n    if (!isAuthors(x))\r\n        throw new Error();\r\n    return x;\r\n}\r\nexports.mustBeAuthors = mustBeAuthors;\r\nfunction isAuthors(x) {\r\n    return ((0, util_1.isArray)(x[\"authors$\"]) && x.type === \"authors\");\r\n}\r\nexports.isAuthors = isAuthors;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.flattenPlainText = exports.isBibComment = exports.CommentEntry = exports.BibComment = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nvar BibComment = (function () {\r\n    function BibComment(data) {\r\n        this.type = \"comment\";\r\n        this.data = data;\r\n        this.string = data.join(\"\");\r\n    }\r\n    BibComment.prototype.toString = function () {\r\n        return this.string;\r\n    };\r\n    return BibComment;\r\n}());\r\nexports.BibComment = BibComment;\r\nvar CommentEntry = (function () {\r\n    function CommentEntry(type, data) {\r\n        this.type = type;\r\n        this.data = data;\r\n        this.string = data.join(\"\");\r\n    }\r\n    CommentEntry.prototype.toString = function () {\r\n        return this.string;\r\n    };\r\n    return CommentEntry;\r\n}());\r\nexports.CommentEntry = CommentEntry;\r\nfunction isBibComment(n) {\r\n    return n.type === \"comment\" && (0, util_1.isArray)(n.data);\r\n}\r\nexports.isBibComment = isBibComment;\r\nvar flattenO = function (wrapper) { return (0, util_1.isString)(wrapper) ? wrapper\r\n    : typeof wrapper === \"number\" ? wrapper.toString()\r\n        : wrapper[\"type\"] === \"@bib\" ? \"@\" + (0, util_1.mustBeString)(wrapper.string)\r\n            : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data)\r\n                : (0, util_1.mustBeString)(wrapper.string); };\r\nfunction flattenPlainText(data) {\r\n    return (0, util_1.flattenMyArray)(data).map(flattenO);\r\n}\r\nexports.flattenPlainText = flattenPlainText;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.processEntry = exports.isBibEntry = exports.parseEntryFields = exports.BibEntry = void 0;\r\nvar Authors_1 = __webpack_require__(9);\r\nvar BibStringEntry_1 = __webpack_require__(7);\r\nvar KeyVal_1 = __webpack_require__(6);\r\nvar BibEntry = (function () {\r\n    function BibEntry(type, id, fields) {\r\n        this.type = type;\r\n        this._id = id;\r\n        this.fields = fields;\r\n        this.sortkey$ = \"\";\r\n        this.title$ = \"\";\r\n    }\r\n    BibEntry.prototype.getField = function (key) {\r\n        return this.fields[key.toLowerCase()];\r\n    };\r\n    BibEntry.prototype.getFieldAsString = function (key) {\r\n        var field = this.getField(key);\r\n        return (0, KeyVal_1.normalizeFieldValue)(field);\r\n    };\r\n    BibEntry.prototype.getAuthors = function () {\r\n        var field = this.fields[\"author\"];\r\n        if (field === undefined)\r\n            return field;\r\n        return (0, Authors_1.mustBeAuthors)(field);\r\n    };\r\n    return BibEntry;\r\n}());\r\nexports.BibEntry = BibEntry;\r\nfunction parseEntryFields(fields) {\r\n    var fieldz = {};\r\n    Object.keys(fields).forEach(function (key) {\r\n        switch (key) {\r\n            default:\r\n                fieldz[key] = (0, KeyVal_1.parseFieldValue)(fields[key]);\r\n                break;\r\n        }\r\n    });\r\n    return fieldz;\r\n}\r\nexports.parseEntryFields = parseEntryFields;\r\nfunction isBibEntry(x) {\r\n    return typeof x[\"type\"] === \"string\"\r\n        && typeof x[\"_id\"] === \"string\"\r\n        && !!x[\"fields\"];\r\n}\r\nexports.isBibEntry = isBibEntry;\r\nfunction processEntry(entry, strings$) {\r\n    var processedFields = {};\r\n    var fields$ = entry.fields;\r\n    Object.keys(entry.fields).forEach(function (key) {\r\n        var field$ = (0, BibStringEntry_1.resolveStringReference)({}, processedFields, strings$, fields$[key]);\r\n        switch (key) {\r\n            case \"author\":\r\n                processedFields[key] = new Authors_1.Authors(field$);\r\n                break;\r\n            case \"title\":\r\n                processedFields[key] = (field$);\r\n                break;\r\n            case \"incollection\":\r\n            default:\r\n                processedFields[key] = field$;\r\n                break;\r\n        }\r\n    });\r\n    return new BibEntry(entry.type, entry._id, processedFields);\r\n}\r\nexports.processEntry = processEntry;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.newPreambleNode = exports.isPreamble = exports.Preamble = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nvar BibFile_1 = __webpack_require__(13);\r\nvar Preamble = (function () {\r\n    function Preamble(data) {\r\n        this.type = (\"preamble\");\r\n        this.data = data;\r\n        this.string = data.join(\"\");\r\n    }\r\n    Preamble.prototype.toString = function () {\r\n        return this.string;\r\n    };\r\n    return Preamble;\r\n}());\r\nexports.Preamble = Preamble;\r\nfunction isPreamble(x) {\r\n    return x.type === \"preamble\" && !!x.data;\r\n}\r\nexports.isPreamble = isPreamble;\r\nfunction newPreambleNode(data) {\r\n    var flattened = (0, BibFile_1.parseBibEntriesAndNonEntries)((0, util_1.mustBeArray)(data.data));\r\n    return new Preamble(flattened);\r\n}\r\nexports.newPreambleNode = newPreambleNode;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseBibFile = exports.parseBibEntriesAndNonEntries = exports.BibFilePresenter = void 0;\r\nvar nearley = __webpack_require__(19);\r\nvar ts_parser_1 = __webpack_require__(20);\r\nvar util_1 = __webpack_require__(0);\r\nvar KeyVal_1 = __webpack_require__(6);\r\nvar BibEntry_1 = __webpack_require__(11);\r\nvar BibComment_1 = __webpack_require__(10);\r\nvar BibPreamble_1 = __webpack_require__(12);\r\nvar BibStringEntry_1 = __webpack_require__(7);\r\nvar Lexer_1 = __webpack_require__(21);\r\nvar BibFilePresenter = (function () {\r\n    function BibFilePresenter(content) {\r\n        var _this = this;\r\n        this.content = content;\r\n        this.comments = content.filter(BibComment_1.isBibComment).map(function (c) {\r\n            if ((0, BibComment_1.isBibComment)(c))\r\n                return c;\r\n            else\r\n                throw new Error();\r\n        });\r\n        this.preambles_raw = content.filter(function (c) { return (0, BibPreamble_1.isPreamble)(c); }).map(function (c) {\r\n            if ((0, BibPreamble_1.isPreamble)(c))\r\n                return c;\r\n            else\r\n                throw new Error();\r\n        });\r\n        this.preamble$ = this.preambles_raw.map(function (p) { return p.toString(); }).join(\"\\n\");\r\n        var strings = {};\r\n        this.content.forEach(function (entry) {\r\n            if ((0, KeyVal_1.isKeyVal)(entry)) {\r\n                if (!!strings[entry.key])\r\n                    throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\r\n                strings[entry.key] = entry.value;\r\n            }\r\n        });\r\n        this.strings_raw = strings;\r\n        this.strings$ = (0, BibStringEntry_1.resolveStrings)(strings);\r\n        this.entries_raw = content.filter(function (c) { return (0, BibEntry_1.isBibEntry)(c); }).map(function (c) {\r\n            if ((0, BibEntry_1.isBibEntry)(c))\r\n                return c;\r\n            else\r\n                throw new Error();\r\n        });\r\n        var entryMap = {};\r\n        this.entries_raw.forEach(function (entry) {\r\n            var key = entry._id.toLowerCase();\r\n            if (!!entryMap[key])\r\n                throw new Error(\"Entry with id \" + key + \" was defined more than once\");\r\n            entryMap[key] = (0, BibEntry_1.processEntry)(entry, _this.strings$);\r\n        });\r\n        this.entries$ = entryMap;\r\n    }\r\n    BibFilePresenter.prototype.getEntry = function (id) {\r\n        return this.entries$[id.toLowerCase()];\r\n    };\r\n    return BibFilePresenter;\r\n}());\r\nexports.BibFilePresenter = BibFilePresenter;\r\nfunction parseNonEntry(nonEntry) {\r\n    if (!(0, util_1.isArray)(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\")\r\n        throw new Error();\r\n    return new BibComment_1.BibComment((0, BibComment_1.flattenPlainText)(nonEntry.data));\r\n}\r\nfunction parseEntry(entry) {\r\n    switch (typeof entry) {\r\n        case \"object\":\r\n            var data = entry.data;\r\n            if (typeof data[\"@type\"] === \"string\") {\r\n                return new BibEntry_1.BibEntry(data[\"@type\"], data._id, (0, BibEntry_1.parseEntryFields)(data.fields));\r\n            }\r\n            var type = (0, util_1.mustBeString)(data.type);\r\n            switch (type) {\r\n                case \"string\":\r\n                    return (0, BibStringEntry_1.newStringEntry)(data);\r\n                case \"preamble\":\r\n                    return (0, BibPreamble_1.newPreambleNode)(data);\r\n                default:\r\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\r\n            }\r\n        default:\r\n            throw new Error(\"Expected object as data for entry\");\r\n    }\r\n}\r\nvar parseBibEntriesAndNonEntries = function (parse) {\r\n    return parse.map(function (entity) {\r\n        switch (entity.type) {\r\n            case \"NON_ENTRY\":\r\n                return (parseNonEntry(entity));\r\n            case \"ENTRY\":\r\n                return (parseEntry(entity));\r\n            default:\r\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\r\n        }\r\n    });\r\n};\r\nexports.parseBibEntriesAndNonEntries = parseBibEntriesAndNonEntries;\r\nfunction parseBibFile(input) {\r\n    var p = new nearley.Parser(ts_parser_1.grammar.ParserRules, ts_parser_1.grammar.ParserStart);\r\n    p.feed(new Lexer_1.default(input).readTokens());\r\n    var res = p.results;\r\n    var parse = res[0];\r\n    return new BibFilePresenter((0, exports.parseBibEntriesAndNonEntries)(parse));\r\n}\r\nexports.parseBibFile = parseBibFile;\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isEscapableChar = exports.escapableChars = exports.isSpecialChar = exports.specialChars = exports.newToken = void 0;\r\nfunction newToken(type, string) {\r\n    return {\r\n        type: type,\r\n        string: string\r\n    };\r\n}\r\nexports.newToken = newToken;\r\nexports.specialChars = {\r\n    \"@\": true,\r\n    \"(\": true,\r\n    \")\": true,\r\n    \"{\": true,\r\n    \"}\": true,\r\n    \"#\": true,\r\n    \"=\": true,\r\n    \",\": true,\r\n    \"\\\\\": true,\r\n    \"\\\"\": true,\r\n};\r\nfunction isSpecialChar(c) {\r\n    return exports.specialChars.hasOwnProperty(c);\r\n}\r\nexports.isSpecialChar = isSpecialChar;\r\nexports.escapableChars = {\r\n    \"\\\\\": true,\r\n    \"@\": true,\r\n    \"{\": true,\r\n    \"}\": true\r\n};\r\nfunction isEscapableChar(c) {\r\n    return exports.escapableChars.hasOwnProperty(c);\r\n}\r\nexports.isEscapableChar = isEscapableChar;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isSingleWhiteSpaceCharacter = exports.singleWhitespaces = exports.isWhitespace = exports.newWhitespace = exports.WS = void 0;\r\nexports.WS = \"ws\";\r\nfunction newWhitespace(string) {\r\n    return {\r\n        type: \"ws\",\r\n        string: string\r\n    };\r\n}\r\nexports.newWhitespace = newWhitespace;\r\nfunction isWhitespace(token) {\r\n    return typeof token.string === \"string\" && token.type === exports.WS;\r\n}\r\nexports.isWhitespace = isWhitespace;\r\nexports.singleWhitespaces = {\r\n    \" \": true,\r\n    \"\\t\": true,\r\n    \"\\r\": true,\r\n    \"\\n\": true\r\n};\r\nfunction isSingleWhiteSpaceCharacter(c) {\r\n    return exports.singleWhitespaces.hasOwnProperty(c);\r\n}\r\nexports.isSingleWhiteSpaceCharacter = isSingleWhiteSpaceCharacter;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isNum = exports.numericChars = exports.newNumber = void 0;\r\nfunction newNumber(string) {\r\n    return {\r\n        type: \"number\",\r\n        string: string\r\n    };\r\n}\r\nexports.newNumber = newNumber;\r\nexports.numericChars = {\r\n    \"0\": true,\r\n    \"1\": true,\r\n    \"2\": true,\r\n    \"3\": true,\r\n    \"4\": true,\r\n    \"5\": true,\r\n    \"6\": true,\r\n    \"7\": true,\r\n    \"8\": true,\r\n    \"9\": true\r\n};\r\nfunction isNum(c) {\r\n    return exports.numericChars.hasOwnProperty(c);\r\n}\r\nexports.isNum = isNum;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(__webpack_require__(8), exports);\r\n__exportStar(__webpack_require__(9), exports);\r\n__exportStar(__webpack_require__(18), exports);\r\n__exportStar(__webpack_require__(10), exports);\r\n__exportStar(__webpack_require__(11), exports);\r\n__exportStar(__webpack_require__(12), exports);\r\n__exportStar(__webpack_require__(7), exports);\r\n__exportStar(__webpack_require__(3), exports);\r\n__exportStar(__webpack_require__(4), exports);\r\n__exportStar(__webpack_require__(24), exports);\r\n__exportStar(__webpack_require__(2), exports);\r\n__exportStar(__webpack_require__(1), exports);\r\n__exportStar(__webpack_require__(5), exports);\r\n__exportStar(__webpack_require__(6), exports);\r\n__exportStar(__webpack_require__(13), exports);\r\n__exportStar(__webpack_require__(0), exports);\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.findError = exports.getOptionalFields = exports.getMandatoryFields = exports.hasMandatoryFields = exports.hasOptionalFields = exports.mandatoryFields = exports.optionalFields = exports.year = exports.volume = exports.type = exports.title = exports.series = exports.school = exports.publisher = exports.pages = exports.organization = exports.number = exports.note = exports.month = exports.journal = exports.institution = exports.howpublished = exports.editor = exports.edition = exports.chapter = exports.booktitle = exports.author = exports.address = void 0;\r\nvar util_1 = __webpack_require__(0);\r\nexports.address = \"address\";\r\nexports.author = \"author\";\r\nexports.booktitle = \"booktitle\";\r\nexports.chapter = \"chapter\";\r\nexports.edition = \"edition\";\r\nexports.editor = \"editor\";\r\nexports.howpublished = \"howpublished\";\r\nexports.institution = \"institution\";\r\nexports.journal = \"journal\";\r\nexports.month = \"month\";\r\nexports.note = \"note\";\r\nexports.number = \"number\";\r\nexports.organization = \"organization\";\r\nexports.pages = \"pages\";\r\nexports.publisher = \"publisher\";\r\nexports.school = \"school\";\r\nexports.series = \"series\";\r\nexports.title = \"title\";\r\nexports.type = \"type\";\r\nexports.volume = \"volume\";\r\nexports.year = \"year\";\r\nexports.optionalFields = {\r\n    \"book\": [[\"volume\", \"number\"], \"series\", \"address\", \"edition\", \"month\", \"note\"],\r\n    \"booklet\": [\"author\", \"howpublished\", \"address\", \"address\", \"month\", \"year\", \"note\"],\r\n    \"conference\": [\"editor\", [\"volume\", \"number\"], \"series\", \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\r\n    \"inproceedings\": [\"editor\", [\"volume\", \"number\"], exports.series, \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\r\n    \"inbook\": [\"volume\", \"number\", \"series\", \"type\", \"address\", \"edition\", \"month\", \"note\"],\r\n    \"incollection\": [\"editor\", [\"volume\", \"number\"], \"series\", \"type\", \"chapter\", \"pages\", \"address\", \"edition\", \"month\", \"note\"],\r\n    \"manual\": [\"author\", \"organization\", \"year\", \"address\", \"edition\", \"month\", \"note\"],\r\n    \"mastersthesis\": [\"type\", \"address\", \"month\", \"note\"],\r\n    \"misc\": [],\r\n    \"phdthesis\": [\"type\", \"address\", \"month\", \"note\"],\r\n    \"proceedings\": [\"editor\", [\"volume\", \"number\"], \"series\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\r\n    \"techreport\": [\"type\", \"address\", \"number\", \"month\", \"note\"],\r\n    \"unpublished\": [\"month\", \"year\"]\r\n};\r\nexports.mandatoryFields = {\r\n    \"article\": [\"author\", \"title\", \"year\", \"journal\"],\r\n    \"book\": [[\"author\", \"editor\"], \"title\", \"publisher\", \"year\"],\r\n    \"booklet\": [\"title\"],\r\n    \"conference\": [\"author\", \"title\", \"booktitle\", \"year\"],\r\n    \"inproceedings\": [\"author\", \"title\", \"booktitle\", \"year\"],\r\n    \"inbook\": [[\"author\", \"editor\"], \"title\", [\"chapter\", \"pages\"]],\r\n    \"incollection\": [\"author\", \"title\", \"booktitle\", \"publisher\", \"year\"],\r\n    \"manual\": [\"title\"],\r\n    \"mastersthesis\": [\"author\", \"title\", \"school\", \"year\"],\r\n    \"misc\": [[\"author\", \"title\", \"howpublished\", \"year\", \"month\", \"note\"]],\r\n    \"phdthesis\": [\"author\", \"title\", \"school\", \"year\"],\r\n    \"proceedings\": [\"year\", \"title\"],\r\n    \"techreport\": [\"author\", \"title\", \"institution\", \"year\"],\r\n    \"unpublished\": [\"author\", \"title\", \"note\"]\r\n};\r\nfunction hasOptionalFields(s) {\r\n    return exports.optionalFields.hasOwnProperty(s);\r\n}\r\nexports.hasOptionalFields = hasOptionalFields;\r\nfunction hasMandatoryFields(s) {\r\n    return exports.mandatoryFields.hasOwnProperty(s);\r\n}\r\nexports.hasMandatoryFields = hasMandatoryFields;\r\nfunction getMandatoryFields(s) {\r\n    if (hasMandatoryFields(s)) {\r\n        return exports.mandatoryFields[s];\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nexports.getMandatoryFields = getMandatoryFields;\r\nfunction getOptionalFields(s) {\r\n    if (hasOptionalFields(s)) {\r\n        return exports.optionalFields[s];\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nexports.getOptionalFields = getOptionalFields;\r\nvar findError = function (entry, field) {\r\n    var fields = entry.fields;\r\n    if ((0, util_1.isString)(field)) {\r\n        if (!fields[field])\r\n            return new Error(\"Warning: expected \" + entry.type + \" with id \" + entry._id\r\n                + \" to have the field: \" + field);\r\n    }\r\n    else if ((0, util_1.isArray)(field)) {\r\n        var hasAllFields = field.reduce(function (acc, fieldName) {\r\n            if ((0, util_1.isString)(fieldName)) {\r\n                return (acc && fields.hasOwnProperty(fieldName));\r\n            }\r\n            else\r\n                throw new Error();\r\n        }, true);\r\n        if (!hasAllFields) {\r\n            return new Error(\"Expected \" + entry.type + \" with id \" + entry._id\r\n                + \" to have one of the following fields: \" + field);\r\n        }\r\n    }\r\n};\r\nexports.findError = findError;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    var token;\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.grammar = void 0;\r\nfunction id(x) {\r\n    return x[0];\r\n}\r\nvar isNumber = function (x) {\r\n    return x.constructor === Number || (typeof x === \"object\" && x.type === \"number\");\r\n};\r\nvar tok_id = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"id\";\r\n    }\r\n};\r\nvar entry_type_bib = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"@bib\";\r\n    }\r\n};\r\nvar entry_type_string = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"@string\";\r\n    }\r\n};\r\nvar entry_type_preamble = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"@preamble\";\r\n    }\r\n};\r\nvar entry_type_comment = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"@comment\";\r\n    }\r\n};\r\nvar ws = {\r\n    test: function (x) {\r\n        return typeof x === \"object\" && x.type === \"ws\";\r\n    }\r\n};\r\nvar num = { test: isNumber };\r\nvar pound = { literal: \"#\" };\r\nvar eq = { literal: \"=\" };\r\nvar esc = { literal: \"\\\\\" };\r\nvar paren_l = { literal: \"(\" };\r\nvar paren_r = { literal: \")\" };\r\nvar brace_l = { literal: \"{\" };\r\nvar brace_r = { literal: \"}\" };\r\nvar quote_dbl = { literal: \"\\\"\" };\r\nvar comma = { literal: \",\" };\r\nfunction addToObj(obj, keyval) {\r\n    if (keyval.type !== \"keyval\")\r\n        throw new Error(\"Expected a keyval object\");\r\n    var key = keyval.key.toLowerCase();\r\n    if (obj.fields[key]) {\r\n        return;\r\n    }\r\n    else {\r\n        obj.fields[key] = keyval.value;\r\n        return obj;\r\n    }\r\n}\r\nfunction joinTokens(arr) {\r\n    var strs = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (typeof arr[i] === \"object\") {\r\n            if (!arr[i].string)\r\n                throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\r\n            strs.push(arr[i].string);\r\n        }\r\n        else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\r\n            strs.push(arr[i]);\r\n        }\r\n        else\r\n            throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\r\n    }\r\n    return strs.join(\"\");\r\n}\r\nexports.grammar = {\r\n    Lexer: undefined,\r\n    ParserRules: [\r\n        { \"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id },\r\n        {\r\n            \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\r\n                return undefined;\r\n            }\r\n        },\r\n        { \"name\": \"main$ebnf$2\", \"symbols\": [] },\r\n        { \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id },\r\n        {\r\n            \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\r\n                return undefined;\r\n            }\r\n        },\r\n        { \"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"] },\r\n        {\r\n            \"name\": \"main$ebnf$2\",\r\n            \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"main\",\r\n            \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\r\n            \"postprocess\": function (data) {\r\n                var topLevelObjects = [];\r\n                if (data[0])\r\n                    topLevelObjects.push({ type: \"NON_ENTRY\", data: data[0] });\r\n                for (var i = 0; i < data[1].length; i++) {\r\n                    topLevelObjects.push({ type: \"ENTRY\", data: data[1][i][0] });\r\n                    if (data[1][i][1])\r\n                        topLevelObjects.push({ type: \"NON_ENTRY\", data: data[1][i][1] });\r\n                }\r\n                return topLevelObjects;\r\n            }\r\n        },\r\n        { \"name\": \"_$ebnf$1\", \"symbols\": [] },\r\n        {\r\n            \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        { \"name\": \"_\", \"symbols\": [\"_$ebnf$1\"] },\r\n        { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        {\r\n            \"name\": \"entry_decl\",\r\n            \"symbols\": [\"entry_decl$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0];\r\n            }\r\n        },\r\n        { \"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"] },\r\n        { \"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"] },\r\n        { \"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"] },\r\n        { \"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"] },\r\n        {\r\n            \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function (data) {\r\n                return data[0][0];\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function (data) {\r\n                return data[0];\r\n            }\r\n        },\r\n        { \"name\": \"comment_liberal$ebnf$1\", \"symbols\": [] },\r\n        { \"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./] },\r\n        {\r\n            \"name\": \"comment_liberal$ebnf$1\",\r\n            \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"comment_liberal\",\r\n            \"symbols\": [\"comment_liberal$ebnf$1\"],\r\n            \"postprocess\": function (data) {\r\n                var toeknz = [];\r\n                for (var tk = 0; tk < data[0].length; tk++)\r\n                    toeknz.push(data[0][tk][0]);\r\n                return toeknz;\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"] },\r\n        {\r\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\r\n            \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\r\n            \"postprocess\": function (data) {\r\n                return data[1];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"] },\r\n        { \"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"] },\r\n        {\r\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\r\n            \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\r\n            \"postprocess\": function (data) {\r\n                return data[1];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"] },\r\n        {\r\n            \"name\": \"entry_body_comment\",\r\n            \"symbols\": [\"entry_body_comment$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0][0];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"] },\r\n        {\r\n            \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\r\n            \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\r\n            \"postprocess\": function (data) {\r\n                return data[2];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"] },\r\n        { \"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"] },\r\n        {\r\n            \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\r\n            \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\r\n            \"postprocess\": function (data) {\r\n                return data[2];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"] },\r\n        {\r\n            \"name\": \"entry_body_string\",\r\n            \"symbols\": [\"entry_body_string$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0][0];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"] },\r\n        {\r\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\r\n            \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\r\n            \"postprocess\": function (data) {\r\n                return data[2];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"] },\r\n        { \"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"] },\r\n        {\r\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\r\n            \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\r\n            \"postprocess\": function (data) {\r\n                return data[2];\r\n            }\r\n        },\r\n        { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"] },\r\n        {\r\n            \"name\": \"entry_body_bib\",\r\n            \"symbols\": [\"entry_body_bib$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0][0];\r\n            }\r\n        },\r\n        { \"name\": \"bib_content$ebnf$1\", \"symbols\": [] },\r\n        { \"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"] },\r\n        {\r\n            \"name\": \"bib_content$ebnf$1\",\r\n            \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        { \"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma] },\r\n        { \"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id },\r\n        {\r\n            \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function () {\r\n                return undefined;\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"bib_content\",\r\n            \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\r\n            \"postprocess\": function (data) {\r\n                var obj = {\r\n                    _id: data[0],\r\n                    fields: []\r\n                };\r\n                var keyvals = data[4];\r\n                for (var kv = 0; kv < keyvals.length; kv++) {\r\n                    obj.fields.push(keyvals[kv][0]);\r\n                }\r\n                obj.fields.push(data[5]);\r\n                return obj;\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"bib_entry\",\r\n            \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\r\n            \"postprocess\": function (data) {\r\n                var obj = {\r\n                    _id: data[2]._id\r\n                };\r\n                obj[\"@type\"] = data[0].string;\r\n                obj.fields = {};\r\n                var keyvals = data[2].fields;\r\n                for (var kv = 0; kv < keyvals.length; kv++) {\r\n                    addToObj(obj, keyvals[kv]);\r\n                }\r\n                return obj;\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"string_entry\",\r\n            \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\r\n            \"postprocess\": function (data) {\r\n                return { type: \"string\", data: data[2] };\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"preamble_entry\",\r\n            \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\r\n            \"postprocess\": function (data) {\r\n                return { type: \"preamble\", data: data[2] };\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"comment_entry\",\r\n            \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\r\n            \"postprocess\": function (data) {\r\n                return { type: \"comment\", data: data[2] };\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"keyval\",\r\n            \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\r\n            \"postprocess\": function (data) {\r\n                return { type: \"keyval\", key: data[0], value: data[4] };\r\n            }\r\n        },\r\n        { \"name\": \"braced_string$ebnf$1\", \"symbols\": [] },\r\n        { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"] },\r\n        { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] },\r\n        {\r\n            \"name\": \"braced_string$ebnf$1\",\r\n            \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"braced_string\",\r\n            \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\r\n            \"postprocess\": function (data) {\r\n                var tkz = [];\r\n                for (var i in data[1])\r\n                    tkz.push(data[1][i][0]);\r\n                return { type: \"braced\", data: tkz };\r\n            }\r\n        },\r\n        { \"name\": \"quoted_string$ebnf$1\", \"symbols\": [] },\r\n        { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"] },\r\n        { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"] },\r\n        { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] },\r\n        {\r\n            \"name\": \"quoted_string$ebnf$1\",\r\n            \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"quoted_string\",\r\n            \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\r\n            \"postprocess\": function (data) {\r\n                var tks = [];\r\n                for (var i in data[1])\r\n                    tks.push(data[1][i][0]);\r\n                return { type: \"quotedstring\", data: tks };\r\n            }\r\n        },\r\n        { \"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r] },\r\n        { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma] },\r\n        { \"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"] },\r\n        { \"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"] },\r\n        {\r\n            \"name\": \"key_string$ebnf$1\",\r\n            \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function (data) {\r\n                return joinTokens(data[0]).toLowerCase();\r\n            }\r\n        },\r\n        { \"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": [] },\r\n        {\r\n            \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\r\n            \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\r\n        },\r\n        {\r\n            \"name\": \"value_string$subexpression$1$ebnf$1\",\r\n            \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"value_string$subexpression$1\",\r\n            \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\r\n        },\r\n        { \"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"] },\r\n        {\r\n            \"name\": \"value_string\",\r\n            \"symbols\": [\"value_string$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                var match = data[0];\r\n                if (match.length === 2) {\r\n                    var tokenz = [];\r\n                    tokenz.push(match[0]);\r\n                    for (var i = 0; i < match[1].length; i++)\r\n                        tokenz.push(match[1][i][3]);\r\n                    return { type: \"quotedstringwrapper\", data: tokenz };\r\n                }\r\n                else if (match[0].type === \"braced\")\r\n                    return { type: \"bracedstringwrapper\", data: match[0].data };\r\n                else\r\n                    throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\r\n            }\r\n        },\r\n        { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"] },\r\n        { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"] },\r\n        { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num] },\r\n        {\r\n            \"name\": \"quoted_string_or_ref\",\r\n            \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                if (data[0][0].type === \"quotedstring\")\r\n                    return data[0][0];\r\n                else {\r\n                    return data[0][0];\r\n                }\r\n            }\r\n        },\r\n        { \"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": [] },\r\n        {\r\n            \"name\": \"string_ref$subexpression$1$ebnf$1\",\r\n            \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"string_ref$subexpression$1\",\r\n            \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\r\n        },\r\n        {\r\n            \"name\": \"string_ref\",\r\n            \"symbols\": [\"string_ref$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                var str = data[0][0] + joinTokens(data[0][1]);\r\n                return { stringref: str };\r\n            }\r\n        },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        {\r\n            \"name\": \"stringreftoken\",\r\n            \"symbols\": [\"stringreftoken$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                if (typeof data[0][0] === \"object\") {\r\n                    if (!data[0][0].string)\r\n                        throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\r\n                    return data[0][0].string;\r\n                }\r\n                else {\r\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\r\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\r\n                    return data[0][0];\r\n                }\r\n            }\r\n        },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        {\r\n            \"name\": \"stringreftoken_n_num\",\r\n            \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                if (typeof data[0][0] === \"object\") {\r\n                    if (!data[0][0].string)\r\n                        throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\r\n                    return data[0][0].string;\r\n                }\r\n                else {\r\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\r\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\r\n                    return data[0][0];\r\n                }\r\n            }\r\n        },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [esc] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [ws] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [num] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [comma] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [pound] },\r\n        { \"name\": \"non_brace$subexpression$1\", \"symbols\": [eq] },\r\n        {\r\n            \"name\": \"non_brace\",\r\n            \"symbols\": [\"non_brace$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0];\r\n            }\r\n        },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [num] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound] },\r\n        { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq] },\r\n        {\r\n            \"name\": \"non_bracket\",\r\n            \"symbols\": [\"non_bracket$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0];\r\n            }\r\n        },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"] },\r\n        { \"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"] },\r\n        { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"] },\r\n        {\r\n            \"name\": \"non_entry$ebnf$1\",\r\n            \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\r\n            \"postprocess\": function arrpush(d) {\r\n                return d[0].concat([d[1]]);\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function (data) {\r\n                var tokens = [];\r\n                for (var Ti = 0; Ti < data[0].length; Ti++)\r\n                    tokens.push(data[0][Ti][0]);\r\n                return tokens;\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function () {\r\n                return \"\\\\\";\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function (data) {\r\n                return { type: \"escapedEntry\", data: data[1] };\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"escaped_non_esc_outside_entry\",\r\n            \"symbols\": [esc, \"non_esc_outside_entry\"],\r\n            \"postprocess\": function (data) {\r\n                return data;\r\n            }\r\n        },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl] },\r\n        { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma] },\r\n        {\r\n            \"name\": \"non_esc_outside_entry\",\r\n            \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\r\n            \"postprocess\": function (data) {\r\n                return data[0][0];\r\n            }\r\n        }\r\n    ],\r\n    ParserStart: \"main\"\r\n};\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Token_1 = __webpack_require__(14);\r\nvar WhitespaceToken_1 = __webpack_require__(15);\r\nvar NumericToken_1 = __webpack_require__(16);\r\nvar IdToken_1 = __webpack_require__(22);\r\nvar BibBlockTypes_1 = __webpack_require__(23);\r\nvar Lexer = (function () {\r\n    function Lexer(string) {\r\n        this.str = string;\r\n        this.len = string.length;\r\n        this.pos = 0;\r\n    }\r\n    Lexer.prototype.getStringUntilNonEscapedChar = function (terminalRegex) {\r\n        var chars = [];\r\n        for (var i = this.pos; i < this.len + 1; i++) {\r\n            this.pos = i;\r\n            if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\r\n                i++;\r\n                this.pos = i;\r\n            }\r\n            else if (this.str.charAt(i).match(terminalRegex)) {\r\n                break;\r\n            }\r\n            chars.push(this.str.charAt(i));\r\n        }\r\n        return chars.join(\"\");\r\n    };\r\n    Lexer.prototype.readTokens = function () {\r\n        var tokens = [];\r\n        var nextToken;\r\n        while (nextToken = this.readNextToken())\r\n            tokens.push(nextToken);\r\n        return tokens;\r\n    };\r\n    Lexer.prototype.readNextToken = function () {\r\n        if (this.pos >= this.str.length)\r\n            return undefined;\r\n        var currentChar = this.str.charAt(this.pos);\r\n        if ((0, WhitespaceToken_1.isSingleWhiteSpaceCharacter)(currentChar))\r\n            return this.eatWhiteSpace();\r\n        else if ((0, Token_1.isSpecialChar)(currentChar)) {\r\n            return this.eatSpecialChars(currentChar);\r\n        }\r\n        else if ((0, NumericToken_1.isNum)(currentChar)) {\r\n            return this.eatNumericString(currentChar);\r\n        }\r\n        else {\r\n            return this.eatIdString();\r\n        }\r\n    };\r\n    Lexer.prototype.eatIdString = function () {\r\n        var chars = [];\r\n        var pos2 = this.pos;\r\n        for (var i = pos2; i < this.len + 1; i++) {\r\n            this.pos = i;\r\n            var charAtI = this.str.charAt(i);\r\n            if (!(0, IdToken_1.isIdChar)(charAtI)) {\r\n                break;\r\n            }\r\n            else {\r\n                chars.push(charAtI);\r\n            }\r\n        }\r\n        return (0, IdToken_1.newIdToken)(chars.join(\"\").trim());\r\n    };\r\n    Lexer.prototype.eatNumericString = function (startAt) {\r\n        var nums = [startAt];\r\n        var nextPos = this.pos + 1;\r\n        for (var newPos = nextPos; newPos < this.len + 1; newPos++) {\r\n            this.pos = newPos;\r\n            var newChar = this.str.charAt(newPos);\r\n            if ((0, NumericToken_1.isNum)(newChar))\r\n                nums.push(newChar);\r\n            else\r\n                break;\r\n        }\r\n        var numericString = nums.join(\"\");\r\n        if (nums[0] === \"0\")\r\n            return (0, NumericToken_1.newNumber)(numericString);\r\n        else {\r\n            var number = Number.parseInt(numericString);\r\n            return Number.isFinite(number) ? number : (0, NumericToken_1.newNumber)(numericString);\r\n        }\r\n    };\r\n    Lexer.prototype.eatSpecialChars = function (startAt) {\r\n        this.pos++;\r\n        if (startAt === \"@\") {\r\n            var type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\r\n            if ((0, BibBlockTypes_1.isBibType)(type))\r\n                return (0, Token_1.newToken)(BibBlockTypes_1.bibTypes[type], type);\r\n            else\r\n                return (0, Token_1.newToken)(\"@bib\", type);\r\n        }\r\n        return startAt;\r\n    };\r\n    Lexer.prototype.eatWhiteSpace = function () {\r\n        var chars = [];\r\n        while (this.pos < this.len + 1) {\r\n            var c = this.str.charAt(this.pos);\r\n            if ((0, WhitespaceToken_1.isSingleWhiteSpaceCharacter)(c)) {\r\n                chars.push(c);\r\n                this.pos++;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        return (0, WhitespaceToken_1.newWhitespace)(chars.join(\"\"));\r\n    };\r\n    return Lexer;\r\n}());\r\nexports.default = Lexer;\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isIdChar = exports.isIdToken = exports.newIdToken = void 0;\r\nvar Token_1 = __webpack_require__(14);\r\nvar WhitespaceToken_1 = __webpack_require__(15);\r\nvar NumericToken_1 = __webpack_require__(16);\r\nfunction newIdToken(string) {\r\n    return {\r\n        type: \"id\",\r\n        string: string\r\n    };\r\n}\r\nexports.newIdToken = newIdToken;\r\nfunction isIdToken(string) {\r\n    return string.type === \"id\" && typeof string.string === \"string\";\r\n}\r\nexports.isIdToken = isIdToken;\r\nfunction isIdChar(c) {\r\n    return !((0, Token_1.isSpecialChar)(c) || (0, NumericToken_1.isNum)(c) || (0, WhitespaceToken_1.isSingleWhiteSpaceCharacter)(c));\r\n}\r\nexports.isIdChar = isIdChar;\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isBibType = exports.bibTypes = void 0;\r\nexports.bibTypes = {\r\n    string: \"@string\",\r\n    preamble: \"@preamble\",\r\n    comment: \"@comment\",\r\n    bib: \"@bib\"\r\n};\r\nvar isBibType = function (c) {\r\n    return exports.bibTypes.hasOwnProperty(c);\r\n};\r\nexports.isBibType = isBibType;\r\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3bc543455d669765ba50","import {BibStringDatum} from \"./bibfile/datatype/string/BibStringData\";\nimport {isStringRef} from \"./bibfile/datatype/string/StringRef\";\nimport {isBibStringComponent} from \"./bibfile/datatype/string/bib-string-utils\";\n\nexport function mustBeString(str: any, o?: any): string {\n    if (typeof str !== \"string\")\n        throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\n    return str;\n}\n\nexport function mustBeDefined<T>(t?: T, o?: any): T {\n    if (t === undefined)\n        throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\n    return t;\n}\n\nexport function mustBeArray(str: any, o?: any): any[] {\n    if (!isArray(str))\n        throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\n    return str;\n}\n\nexport function isArray(data: any): data is any[] {\n    return !!data && data.constructor === Array;\n}\n\nexport function isNumber(data: any): data is number {\n    return typeof data === \"number\";\n}\n\n\nexport function isString(data: any): data is string {\n    return typeof data === \"string\";\n}\n\nexport const flattenMyArray = function (arr: any[], result?: any[]): any[] {\n    if (!result) result = [];\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value: any = arr[i];\n        if (Array.isArray(value)) {\n            for (let i = 0, length = value.length; i < length; i++) {\n                const value2: any = value[i];\n                if (Array.isArray(value2)) {\n                    flattenMyArray(value2, result);\n                } else {\n                    result.push(value2);\n                }\n            }\n        } else {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/util.ts","import {\n    BibOuterStringComponent,\n    BibStringComponent\n} from \"./BibStringComponent\";\n\nimport {BibStringData} from \"./BibStringData\";\n\n/**\n * thisObject = \"A string between quotes\"\n */\nexport class QuotedString extends BibStringComponent {\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"quotedstring\", braceDepth, data);\n    }\n}\n\nexport class OuterQuotedString extends BibOuterStringComponent {\n    constructor(data: BibStringData) {\n        super(\"quotedstringwrapper\", data);\n    }\n}\n\nexport function isOuterQuotedString(x: any): x is OuterQuotedString {\n    return x.type === \"quotedstringwrapper\";\n}\n\nexport function isQuotedString(x: any): x is QuotedString {\n    return x.type === \"quotedstring\";\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/string/QuotedString.ts","\nimport {BibOuterStringComponent, BibStringComponent} from \"./BibStringComponent\";\nimport {BibStringData} from \"./BibStringData\";\n\n/**\n * thisObject = {A string between braces}\n */\nexport class BracedString extends BibStringComponent {\n\n    /**\n     * A special character is a\n     * part of a field starting with a left brace being at brace depth 0 immediately followed with a backslash,\n     * and ending with the corresponding right brace.\n     * It should be noticed that anything in a special character is\n     * considered as being at brace depth 0, even if it is placed between another pair of braces.\n     */\n    readonly isSpecialCharacter: boolean;\n\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"bracedstring\", braceDepth, data);\n\n        // TODO braced strings inside a special character is treated as if it has brace depth 0. Maybe it's a good idea to mark these nested braces?\n        this.isSpecialCharacter = braceDepth === 0 && data[0] === \"\\\\\";\n    }\n\n}\n\nexport class OuterBracedString extends BibOuterStringComponent {\n    constructor(data: BibStringData) {\n        super(\"bracedstringwrapper\", data);\n    }\n}\n\nexport function isOuterBracedString(x: any): x is OuterBracedString {\n    return x.type === \"bracedstringwrapper\";\n}\n\nexport function isBracedString(x: any): x is BracedString {\n    return x.type === \"bracedstring\";\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/string/BracedString.ts","import {isStringRef, StringRef} from \"./StringRef\";\nimport {isBracedString, isOuterBracedString, BracedString} from \"./BracedString\";\nimport {isOuterQuotedString, isQuotedString, QuotedString} from \"./QuotedString\";\nimport {flattenMyArray, isArray, isNumber, isString, mustBeString} from \"../../../util\";\nimport {BibStringComponent} from \"./BibStringComponent\";\nimport {BibStringData, BibStringDatum} from \"./BibStringData\";\n\nexport function isBibStringComponent(x: any): x is BibStringComponent {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\n\nexport interface ContiguousSimpleString {\n    type: \"ContiguousSimpleString\";\n    data: (number | string)[];\n}\n\nexport function isContiguousSimpleString(x: any): x is ContiguousSimpleString {\n    return x.type === \"ContiguousSimpleString\" && isArray(x.data);\n}\n\nexport function joinContiguousSimpleStrings(x: ContiguousSimpleString): string {\n    return x.data.join(\"\");\n}\n\n\nexport function parseStringComponent(braceDepth: number, obj: any): BibStringComponent | string | number | StringRef {\n    if (isNumber(obj) || isString(obj))\n        return /*new BibStringComponent(typeof obj, braceDepth, [*/obj/*])*/;\n\n    if (isStringRef(obj))\n        return new StringRef(0, obj.stringref);\n    // if (isWhitespace(obj)) return obj;\n    // if (isIdToken(obj)) return obj.string;\n\n    switch (mustBeString(obj.type, obj)) {\n        case \"id\":\n        case \"ws\":\n        case \"number\":\n            return mustBeString(obj.string);\n        case \"bracedstring\":\n        case \"braced\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            return new BracedString(braceDepth, flattenMyArray(obj.data).map(e => parseStringComponent(braceDepth + 1, e)));\n        case \"quotedstring\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            const flattened = flattenMyArray(obj.data);\n            return new QuotedString(braceDepth, flattened.map(e => parseStringComponent(braceDepth, e)));\n        default:\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\n    }\n}\n\nexport function toStringBibStringDatum(data: BibStringDatum): string {\n    if (isString(data))\n        return data;\n    if (isNumber(data))\n        return data + \"\";\n    if (\n        isBracedString(data)\n        || isQuotedString(data)\n        || isOuterQuotedString(data)\n        || isOuterBracedString(data)\n    )\n        return toStringBibStringData(data.data);\n\n    throw new Error(JSON.stringify(data));\n}\n\nexport function toStringBibStringData(data: BibStringData) {\n    return data.map(toStringBibStringDatum).join(\"\");\n}\n\nexport function flattenQuotedStrings(data: BibStringData, hideQuotes?: boolean): BibStringData {\n    let result: BibStringData = [];\n    for (const datum of data) {\n        const flattenned = flattenQuotedString(datum, hideQuotes);\n        if (isArray(flattenned)) {\n            result = result.concat(flattenned);\n        } else {\n            result.push(flattenned);\n        }\n    }\n    return result;\n}\n\nconst doubleQuotes: BibStringDatum[] = [\"\\\"\"];\n\nfunction flattenQuotedString(data: BibStringDatum, hideQuotes?: boolean): BibStringDatum | BibStringData {\n    if (isBracedString(data))\n        return data;\n    if (isQuotedString(data)) {\n        const flattenedQuotedString: BibStringData = flattenQuotedStrings(data.data, true);\n        if (isArray(flattenedQuotedString)) {\n            return hideQuotes\n                ? flattenedQuotedString\n                : doubleQuotes.concat(flattenedQuotedString).concat(doubleQuotes);\n        } else if (hideQuotes)\n            return flattenedQuotedString;\n        else\n            return [\"\\\"\", flattenedQuotedString, \"\\\"\"];\n    }\n    if (isOuterQuotedString(data))\n        return flattenQuotedStrings(data.data, true);\n    if (isOuterBracedString(data))\n        return flattenQuotedStrings(data.data, false);\n    if (isString(data) || isNumber(data))\n        return data;\n    if (isStringRef(data))\n        throw new Error(\"StringRef should be resolved at this point!\");\n    else\n        throw new Error();\n}\n\nexport function globContiguousStrings(data: BibStringData): (BibStringDatum | ContiguousSimpleString)[] {\n    const result: (BibStringDatum | ContiguousSimpleString)[] = [];\n    for (const element of data) {\n        if (isString(element) || isNumber(element)) {\n            if (result.length <= 0) {\n                const contiguousSimpleString: ContiguousSimpleString = {\n                    type: \"ContiguousSimpleString\",\n                    data: [element]\n                };\n                result.push(contiguousSimpleString);\n            }\n            else {\n                const lastElement = result[result.length - 1];\n                if (isContiguousSimpleString(lastElement)) {\n                    lastElement.data.push(element);\n                } else {\n                    const contiguousSimpleString: ContiguousSimpleString = {\n                        type: \"ContiguousSimpleString\",\n                        data: [element]\n                    };\n                    result.push(contiguousSimpleString);\n                }\n            }\n        } else {\n            result.push(element);\n        }\n    }\n    return result;\n}\n\nexport function splitOnAnd(data: BibStringData): BibStringData[] {\n    return splitOnPattern(data, /\\s+and\\s+/g);\n}\n\nexport function splitOnComma(data: BibStringData, limit = 2): BibStringData[] {\n    return splitOnPattern(data, /\\s*,\\s*/g, limit);\n}\n\nexport function splitOnPattern(data: BibStringData, pattern: RegExp, stopAfter?: number): BibStringData[] {\n    const splitted: BibStringData[] = [];\n\n    let buffer: BibStringData = [];\n    for (const datum of data) {\n        if (isString(datum) && (stopAfter === undefined || stopAfter > 0)) {\n            let match: RegExpExecArray | null | undefined = pattern.exec(datum);\n            let end = 0;\n            if (match) {\n                do {\n                    const prevEnd = end;\n                    end = match.index + match[0].length;\n                    // if(prevEnd !== match.index)\n                    buffer.push(datum.substring(prevEnd, match.index));\n\n                    if (stopAfter === undefined || stopAfter > 0) {\n                        splitted.push(buffer);\n                        buffer = [];\n                        if (stopAfter !== undefined && stopAfter > 0) stopAfter--;\n                    }\n\n                    if (stopAfter === undefined || stopAfter > 0)\n                        match = pattern.exec(datum);\n                    else\n                        match = undefined;\n                } while (match);\n\n                if (end > 0 && end < datum.length)\n                    buffer.push(datum.substring(end));\n            } else {\n                buffer.push(datum);\n            }\n        }\n        else\n            buffer.push(datum);\n    }\n\n    if (buffer.length > 0) splitted.push(buffer);\n    return splitted;\n}\n\n// TODO\n// /**\n//  * A special character is a\n//  part of a field starting with a left brace being at brace depth 0 immediately followed with a backslash,\n//  and ending with the corresponding right brace. For instance, in the above example, there is no special\n//  character, since \\LaTeX is at depth 2. It should be noticed that anything in a special character is\n//  considered as being at brace depth 0, even if it is placed between another pair of braces.\n//  */\n// export class SpecialCharacter extends BibStringComponent {\n//     constructor(data: BibStringData) {\n//         super(\"specialCharacter\", 0, data);\n//     }\n//\n//     copyWithResolvedStringReferences(alreadyResolved, refs): BibStringComponent {\n//         return new SpecialCharacter(resolveStringReferences(this,(alreadyResolved, refs));\n//     }\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/string/bib-string-utils.ts","import {BibStringData, BibStringDatum} from \"./BibStringData\";\nimport {isNumber, isString} from \"../../../util\";\n\n/**\n * A fully formed string (between {braces} or \"quotes\").\n * Consists of 0 or many BibStringDatum\n */\nexport class BibStringComponent {\n    readonly data: BibStringData;\n    readonly type: string;\n\n    /**\n     * The brace depth of an item is the number of braces surrounding it (surrounding the field with braces instead of quotes does not modify the brace depth)\n     */\n    readonly braceDepth: number;\n\n    constructor(type: string, braceDepth: number, data: BibStringData) {\n        this.type = type;\n        this.braceDepth = braceDepth;\n        this.data = data;\n    }\n\n\n    stringify(): string {\n        return this.data.map(stringifyDatum).join(\"\");\n    }\n}\n\nfunction isBibStringComponent(x: any): x is BibStringComponent {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\n\nexport function stringifyDatum(datum: BibStringDatum): string {\n    if (isString(datum)) return datum;\n    if (isNumber(datum)) return datum.toString();\n    if (isBibStringComponent(datum)) return datum.stringify();\n    // if (isStringRef(datum)) throw new Error(\"Unexpected state\");\n    else throw new Error(\"Unexpected state\");\n}\n\nexport class BibOuterStringComponent extends BibStringComponent {\n    constructor(type: string, data: BibStringData) {\n        super(type, 0, data);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/string/BibStringComponent.ts","/**\n * A named reference to a string, eg. `{string1} # stringRef # {string2}`\n */\nexport class StringRef {\n    readonly stringref: string;\n    readonly braceDepth: number;\n\n    constructor(braceDepth: number, stringref: string) {\n        this.braceDepth = braceDepth;\n        this.stringref = stringref;\n    }\n}\n\nexport function isStringRef(stringref: any): stringref is StringRef {\n    return typeof stringref.stringref === \"string\";\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/string/StringRef.ts","import {OuterBracedString} from \"./string/BracedString\";\nimport {OuterQuotedString} from \"./string/QuotedString\";\nimport {isNumber, mustBeArray} from \"../../util\";\nimport {parseStringComponent} from \"./string/bib-string-utils\";\nimport {BibOuterStringComponent} from \"./string/BibStringComponent\";\n\n/**\n * A key to value mapping such as `field = {name}`.\n */\nexport interface KeyVal {\n    readonly key: string;\n    readonly value: FieldValue;\n}\n\nexport function isKeyVal(data: any): data is KeyVal {\n    return typeof data.key === \"string\"\n        && data.value !== undefined;\n}\n\nexport function newKeyVal(data: any): KeyVal {\n    if (isKeyVal(data)) {\n        return {\n            key: data.key,\n            value: parseFieldValue(data.value),\n        };\n    } else {\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\n    }\n}\n\nexport function parseFieldValue(value: any): FieldValue {\n    if (isNumber(value)) {\n        return value;\n    }\n\n    const data = mustBeArray(value.data);\n    switch (value.type) {\n        case \"quotedstringwrapper\":\n            if (data.length === 1 && isNumber(data[0]))\n            // A single number is in a quoted string wrapper\n            // because the parser considered it part of a\n            // concatenated string\n                return data[0];\n\n            return new OuterQuotedString(data.map(e => parseStringComponent(0, e)));\n\n        case \"bracedstringwrapper\":\n            return new OuterBracedString(data.map(e => parseStringComponent(0, e)));\n\n        default:\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\n    }\n}\n\n/**\n * Values (i.e. right hand sides of each assignment) can be either between curly braces or between\n * double quotes. The main difference is that you can write double quotes in the first case, and not\n * in the second case.\n *\n * For numerical values, curly braces and double quotes can be omitted.\n */\nexport type FieldValue = number | BibOuterStringComponent;\n\nexport function normalizeFieldValue(field?: FieldValue): string | number | undefined {\n    if(!field) return undefined;\n    if(isNumber(field)) return field;\n    else return field.stringify();\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/datatype/KeyVal.ts","import {KeyVal, isKeyVal, newKeyVal, FieldValue} from \"../datatype/KeyVal\";\nimport {isStringRef, StringRef} from \"../datatype/string/StringRef\";\nimport {isOuterQuotedString, isQuotedString, OuterQuotedString, QuotedString} from \"../datatype/string/QuotedString\";\nimport {BracedString, isBracedString, isOuterBracedString, OuterBracedString} from \"../datatype/string/BracedString\";\nimport {isNumber, isString} from \"../../util\";\nimport {BibStringComponent} from \"../datatype/string/BibStringComponent\";\nimport {BibStringData} from \"../datatype/string/BibStringData\";\nimport {isBibStringComponent} from \"../datatype/string/bib-string-utils\";\n\n/**\n * An \"@string{}\" entry\n */\nexport class BibStringEntry {\n    readonly type: string;\n\n    readonly key: string;\n    readonly value: FieldValue;\n\n    public constructor(key: string, value: FieldValue) {\n        this.type = \"string\";\n        this.key = key;\n        this.value = value;\n    }\n}\n\nexport function newStringEntry(data: any): BibStringEntry {\n    const {key, value}: KeyVal = convertToKeyVal(data);\n    return new BibStringEntry(key, value);\n}\n\nfunction convertToKeyVal(data: any): KeyVal {\n    if (isKeyVal(data)) {\n        return newKeyVal(data);\n    } else {\n        if (data.type !== \"string\") {\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\n        }\n        return convertToKeyVal(data.data);\n    }\n}\n\n// function resolveStringDeclarations(wrapper: FieldValue,\n//                                    compiledSoFar: { [key: string]: FieldValue },\n//                                    rawStrings: { [key: string]: FieldValue }) {\n//     if (isNumber(wrapper))\n//         return wrapper;\n//\n//     return copyWithResolvedStringReferences(wrapper, compiledSoFar, rawStrings);\n//\n//     //  else\n//     //    throw new Error(\"Unexpected object to resolve: \" + JSON.stringify(wrapper));\n// }\n\nexport function resolveStrings(strings: { [key: string]: FieldValue }): { [key: string]: FieldValue } {\n    const resolved: { [key: string]: FieldValue } = {};\n    Object.keys(strings).forEach(key => {\n        if (!resolved[key])\n            resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\n    });\n    return resolved;\n}\n\nexport function resolveStringReferences(o: BibStringComponent, seenBeforeStack: { [key: string]: boolean },\n                                        alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                        refs: { [key: string]: FieldValue }): BibStringData {\n    return o.data.map(datum => {\n        if (isString(datum) || isNumber(datum)) return datum;\n        else if (isStringRef(datum)) return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);\n        else if (isBibStringComponent(datum)) return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);\n        else throw new Error();\n    });\n}\n\nexport function resolveStringReference(seenBeforeStack: { [key: string]: boolean },\n                                       alreadyResolved: { [p: string]: FieldValue },\n                                       refs: { [p: string]: FieldValue },\n                                       data: FieldValue): FieldValue {\n    if (isNumber(data)) {\n        return data;\n    } else if (isOuterBracedString(data) || isOuterQuotedString(data)) {\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\n    }\n    if (isStringRef(data)) {\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\n    }\n\n    // else if (isBibStringComponent(data))\n    //     return data.copyWithResolvedStringReferences(alreadyResolved, refs);\n    // else throw new Error();\n    return data;\n}\n\nfunction resolveStringRef(seenBeforeStack: { [key: string]: boolean },\n                          refs: { [key: string]: FieldValue },\n                          data: StringRef,\n                          alreadyResolved: { [key: string]: FieldValue }): FieldValue {\n    const refName = data.stringref;\n    if (seenBeforeStack[refName])\n        throw new Error(\"Cycle detected: \" + refName);\n    if (alreadyResolved[refName]) {\n        return alreadyResolved[refName];\n    }\n    if (!refs[refName])\n        throw new Error(`Unresolved reference: \"${data.stringref}\" (${JSON.stringify(data)})`);\n\n    alreadyResolved[refName] = resolveStringReference(\n        Object.assign({}, seenBeforeStack, {[refName]: true}),\n        alreadyResolved,\n        refs,\n        refs[refName]\n    );\n    return alreadyResolved[refName];\n}\n\n\nexport function copyWithResolvedStringReferences(obj: BibStringComponent,\n                                                 seenBeforeStack: { [key: string]: boolean },\n                                                 alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                 refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n\n    const braceDepth: number = obj.braceDepth;\n    if (isQuotedString(obj))\n        return new QuotedString(braceDepth, newData);\n    if (isBracedString(obj))\n        return new BracedString(braceDepth, newData);\n    if (isOuterQuotedString(obj))\n        return new OuterQuotedString(newData);\n    if (isOuterBracedString(obj))\n        return new OuterBracedString(newData);\n    else\n        throw new Error();\n}\n\nexport function copyOuterWithResolvedStringReferences(obj: OuterQuotedString | OuterBracedString,\n                                                      seenBeforeStack: { [key: string]: boolean },\n                                                      alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                      refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const copied = copyWithResolvedStringReferences(\n        obj,\n        seenBeforeStack,\n        alreadyResolved,\n        refs\n    );\n    if (!isOuterBracedString(copied) && !isOuterQuotedString(copied)) throw new Error();\n    return copied;\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/BibStringEntry.ts","import {BibStringData, BibStringDatum} from \"../../datatype/string/BibStringData\";\nimport {isString} from \"../../../util\";\nimport {isOuterQuotedString, isQuotedString} from \"../../datatype/string/QuotedString\";\nimport {isStringRef} from \"../../datatype/string/StringRef\";\nimport {isOuterBracedString} from \"../../datatype/string/BracedString\";\nimport {\n    splitOnAnd,\n    splitOnComma,\n    splitOnPattern,\n    toStringBibStringData,\n    toStringBibStringDatum\n} from \"../../datatype/string/bib-string-utils\";\n\nfunction word2string(obj) {\n    if (typeof obj === \"string\") return obj;\n    else if (obj.type == \"braced\") return word2string(obj.data);\n    else if (obj.unicode) return obj.unicode;\n    else if (obj.string) return obj.string;\n    else if (obj.constructor == Array) return obj.map(word2string).join(\"\");\n    else throw new Error(\"? \" + JSON.stringify(obj));\n}\n\nconst WHITESPACES = /\\s+/g;\n\nexport class AuthorName {\n    readonly firstNames$: BibStringData[];\n    readonly initials: string[];\n    readonly vons$: BibStringData[];\n    readonly lastNames$: BibStringData[];\n    readonly jrs$: BibStringData[];\n\n    readonly firstNames: string[];\n    readonly vons: string[];\n    readonly lastNames: string[];\n    readonly jrs: string[];\n\n    readonly id: string;\n\n    /**\n     * @param firstNames Array of word objects\n     * @param vons Array of word objects\n     * @param lastNames Array of word objects\n     * @param jrs Array of word objects\n     */\n    constructor(firstNames: BibStringData[], vons: BibStringData[], lastNames: BibStringData[], jrs: BibStringData[]) {\n        this.firstNames$ = firstNames;\n        this.vons$ = vons;\n        this.lastNames$ = lastNames;\n        this.jrs$ = jrs;\n\n        this.initials = firstNames.map(getFirstLetter);\n\n        this.firstNames = firstNames.map(toStringBibStringData);\n        this.vons = vons.map(toStringBibStringData);\n        this.lastNames = lastNames.map(toStringBibStringData);\n        this.jrs = jrs.map(toStringBibStringData);\n\n        this.id = this.firstNames.join(\"-\") + \"-\"\n            + this.vons.join(\"-\") + \"-\"\n            + this.lastNames.join(\"-\") + \"-\"\n            + this.jrs.join(\"-\");\n    }\n}\n\nfunction getFirstLetter(bsd: BibStringData): string {\n    const asString = toStringBibStringData(bsd);\n    return asString ? asString.charAt(0) : \"\";\n}\n\nfunction isPartOfName(char) {\n    return (char === \",\" || char.match(/\\s/));\n}\n\nfunction startsWithLowerCaseBSD(authorToken: BibStringData) {\n    if (authorToken.length > 0) return startsWithLowerCase(authorToken[0]);\n    else return false;\n}\n\nfunction startsWithLowerCase(authorToken: BibStringDatum) {\n    if (isString(authorToken)) {\n        if (!authorToken) return false;\n        const ch = authorToken.charAt(0);\n        return ch.toLowerCase() === ch && ch.toUpperCase() !== ch;\n    }\n\n    if (isQuotedString(authorToken)) {\n        // TODO must be flattened string...?\n        if (!authorToken.data || authorToken.data.length <= 0) return false;\n        return startsWithLowerCase(authorToken.data[0]);\n    }\n\n    if (isStringRef(authorToken)\n        || isOuterQuotedString(authorToken)\n        || isOuterBracedString(authorToken)\n    ) throw new Error(\"Should not do this test on this type\");\n\n    return false;\n}\n\nfunction firstVonLast(outer: BibStringData): AuthorName {\n    const authorTokens: BibStringData[] = splitOnPattern(outer, WHITESPACES);\n\n    let vonStartInclusive = -1;\n    let vonEndExclusive = -1;\n    let firstNameEndExclusive = -1;\n\n    for (let i = 0; i < authorTokens.length - 1; i++) {\n        if (startsWithLowerCaseBSD(authorTokens[i])) {\n            if (vonStartInclusive < 0)\n            // Start von if not already started\n                vonStartInclusive = i;\n            // End von at last word that starts with lowercase\n            vonEndExclusive = i + 1;\n        }\n    }\n    if (vonStartInclusive >= 0) firstNameEndExclusive = vonStartInclusive;\n    else firstNameEndExclusive = authorTokens.length - 1;\n\n    const von: BibStringData[] = vonStartInclusive >= 0 ? getSubStringAsArray(authorTokens, vonStartInclusive, vonEndExclusive) : [];\n    const firstName: BibStringData[] = getSubStringAsArray(authorTokens, 0, firstNameEndExclusive);\n    const lastName: BibStringData[] = getSubStringAsArray(authorTokens, Math.max(vonEndExclusive, firstNameEndExclusive), authorTokens.length);\n\n    return new AuthorName(\n        firstName,\n        von,\n        lastName,\n        []\n    );\n}\n\nfunction vonLastFirst(vonLastStr: BibStringData, firstStr: BibStringData) {\n    const vonLast = splitOnPattern(vonLastStr, WHITESPACES);\n    const first = splitOnPattern(firstStr, WHITESPACES);\n\n    let vonStartInclusive = -1;\n    let vonEndExclusive = -1;\n\n    for (let i = 0; i < vonLast.length - 1; i++)\n        if (startsWithLowerCaseBSD(vonLast[i])) {\n            if (vonStartInclusive < 0) vonStartInclusive = i;\n            vonEndExclusive = i + 1;\n        }\n\n    const von = vonStartInclusive >= 0 ? getSubStringAsArray(vonLast, 0, vonEndExclusive) : [];\n    const firstName = first;\n    const lastName = getSubStringAsArray(vonLast, Math.max(vonEndExclusive, 0));\n\n    return new AuthorName(\n        firstName,\n        von,\n        lastName,\n        []\n    );\n}\n\n\nfunction getSubStringAsArray<T>(tokens: T[], startIncl: number, endExcl?: number) {\n    const arr: T[] = [];\n    for (let i = startIncl; i < (endExcl === undefined ? tokens.length : endExcl); i++) {\n        arr.push(tokens[i]);\n    }\n    return arr;\n}\n\nfunction vonLastJrFirst(vonLastStr: BibStringData, jrStr: BibStringData, firstStr: BibStringData) {\n    const vonLast = splitOnPattern(vonLastStr, WHITESPACES);\n    const first = splitOnPattern(firstStr, WHITESPACES);\n    const jr = splitOnPattern(jrStr, WHITESPACES);\n\n    let vonStartInclusive = -1;\n    let vonEndExclusive = -1;\n\n    for (let i = 0; i < vonLast.length - 1; i++)\n        if (startsWithLowerCaseBSD(vonLast[i])) {\n            if (vonStartInclusive < 0) vonStartInclusive = i;\n            vonEndExclusive = i + 1;\n        }\n\n    const von = vonStartInclusive >= 0 ? getSubStringAsArray(vonLast, 0, vonEndExclusive) : [];\n    const lastName = getSubStringAsArray(vonLast, Math.max(vonEndExclusive, 0));\n\n    return new AuthorName(\n        first,\n        von,\n        lastName,\n        jr\n    );\n}\n\n/**\n * BibTEX must be able to distinguish between the different parts of the author field. To that\n * aim, BibTEX recognizes three possible formats:\n *  First von Last;\n *  von Last, First;\n *  von Last, Jr, First.\n *\n * The format to be considered is obtained by counting the number of commas in the name.\n */\nexport function parseAuthorName(normalizedFieldValue: BibStringData): AuthorName {\n    const partitions: BibStringData[] = splitOnComma(normalizedFieldValue);\n\n    switch (partitions.length) {\n        case 1:\n            return firstVonLast(partitions[0]);\n        case 2:\n            return vonLastFirst(mdbsd(partitions[0]), mdbsd(partitions[1]));\n        case 3:\n            return vonLastJrFirst(mdbsd(partitions[0]), mdbsd(partitions[1]), mdbsd(partitions[2]));\n        default:\n            throw new Error(`Could not parse author name: partitioned as ${JSON.stringify(partitions)} in ${JSON.stringify(normalizedFieldValue)}`);\n    }\n}\n\nfunction isdbsd(x: any): x is BibStringData {\n    return x !== undefined;\n}\n\nfunction mdbsd(x: any): BibStringData {\n    if (isdbsd(x)) return x; else throw new Error(\"???????\");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/bibliographic-entity/Author.ts","import {isArray, isNumber} from \"../../../util\";\nimport {AuthorName, parseAuthorName} from \"./Author\";\nimport {isOuterQuotedString} from \"../../datatype/string/QuotedString\";\nimport {BibOuterStringComponent} from \"../../datatype/string/BibStringComponent\";\nimport {BibStringData} from \"../../datatype/string/BibStringData\";\nimport {\n    flattenQuotedStrings,\n    globContiguousStrings,\n    isContiguousSimpleString,\n    joinContiguousSimpleStrings,\n    splitOnAnd\n} from \"../../datatype/string/bib-string-utils\";\nimport {FieldValue} from \"../../datatype/KeyVal\";\n\n\n/**\n * Represents a list of authors\n */\nexport class Authors extends BibOuterStringComponent {\n    readonly authors$: AuthorName[];\n\n    constructor(fieldValue: FieldValue) {\n        const data = isNumber(fieldValue) ? [fieldValue] : fieldValue.data;\n        super(\"authors\", data);\n\n        const authorNames = determineAuthorNames$(fieldValue);\n        this.authors$ = authorNames.map(name => parseAuthor(name));\n    }\n}\n\n\nfunction parseAuthor(data: BibStringData) {\n    return parseAuthorName(data);\n}\n\n\nexport function determineAuthorNames$(data: FieldValue): BibStringData[] {\n    if (isNumber(data)) {\n        return determineAuthorNames([data]);\n    } else {\n        return determineAuthorNames(data.data, isOuterQuotedString(data));\n    }\n}\n\n\nfunction determineAuthorNames(data: BibStringData, hideQuotes?: boolean): BibStringData[] {\n    const globbed = globContiguousStrings(\n        flattenQuotedStrings(data, hideQuotes)\n    );\n    const normalizedString: BibStringData = globbed.map(e => isContiguousSimpleString(e) ? joinContiguousSimpleStrings(e) : e);\n    return splitOnAnd(normalizedString);\n}\n\n\nexport function mustBeAuthors(x: any): Authors {\n    if (!isAuthors(x)) throw new Error();\n    return x;\n}\n\n\nexport function isAuthors(x: any): x is Authors {\n    return (isArray(x[\"authors$\"]) && x.type === \"authors\");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/bibliographic-entity/Authors.ts","import {flattenMyArray, isArray, isString, mustBeString} from \"../../util\";\n\nexport class BibComment {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(data: string[]) {\n        this.type = \"comment\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport class CommentEntry {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(type: string, data: string[]) {\n        this.type = type;\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport function isBibComment(n: any): n is BibComment {\n    return n.type === \"comment\" && isArray(n.data);\n}\n\nconst flattenO = (wrapper: any): string => isString(wrapper) ? wrapper\n    : typeof wrapper === \"number\" ? wrapper.toString()\n        // : (isString(wrapper.type) && wrapper.type === \"@bib\" && isString(wrapper.string)) ? \"@\" + wrapper.string\n        : wrapper[\"type\"] === \"@bib\" ? \"@\" + mustBeString(wrapper.string)\n            : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data)\n                : mustBeString(wrapper.string)\n;\n\nexport function flattenPlainText(data: any[]): string[] {\n    return flattenMyArray(data).map(flattenO);\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/BibComment.ts","import {Authors, mustBeAuthors} from \"./bibliographic-entity/Authors\";\nimport {\n    findError,\n    hasMandatoryFields,\n    mandatoryFields\n} from \"./bibliographic-entity/mandatory-and-optional-fields\";\nimport {resolveStringReference} from \"./BibStringEntry\";\nimport {FieldValue, normalizeFieldValue, parseFieldValue} from \"../datatype/KeyVal\";\n\n/**\n * Represents a single \"@[entityName]\" entity, not a special entity such as @string\n */\nexport class BibEntry {\n    readonly type: string;\n    readonly _id: string;\n\n    readonly fields: EntryFields;\n    // noinspection JSUnusedGlobalSymbols\n    readonly fields$: EntryFields;\n\n    /**\n     * When sorting, BibTEX computes a string, named\n     sort.key$, for each entry. The sort.key$ string is an (often long) string defining the order\n     in which entries will be sorted. To avoid any ambiguity, sort.key$ should only contain alphanumeric\n     characters. Classical non-alphanumeric characters23, except special characters, will\n     be removed by a BibTEX function named purify$. For special characters, purify$ removes\n     spaces and LATEX commands (strings beginning with a backslash), even those placed between\n     brace pairs. Everything else is left unmodified. For instance, t\\^ete, t{\\^e}te and t{\\^{e}}te\n     are transformed into tete, while tte gives tte; Bib{\\TeX} gives Bib and Bib\\TeX becomes\n     BibTeX. There are thirteen LATEX commands that wont follow the above rules: \\OE, \\ae, \\AE,\n     \\aa, \\AA, \\o, \\O, \\l, \\L, \\ss. Those commands correspond to , , , , , , , , , , , ,\n     , and purify$ transforms them (if they are in a special character, in i, j, oe, OE, ae, AE, aa,\n     AA, o, O, l, L, ss, respectively.\n     */\n    readonly sortkey$: string;\n\n    /**\n     the second transformation applied to a title is to be turned to lower case (except the first character).\n     The function named change.case$ does this job. But it only applies to letters that are\n     a brace depth 0, except within a special character. In a special character, brace depth is always\n     0, and letters are switched to lower case, except LATEX commands, that are left unmodified.\n     */\n    readonly title$: string;\n\n    constructor(type: string, id: string, fields: EntryFields) {\n        this.type = type;\n        this._id = id;\n\n        this.fields = fields;\n\n\n        // TODO implement; see above\n        this.sortkey$ = \"\";\n        this.title$ = \"\";\n    }\n\n    getField(key: string): FieldValue | undefined {\n        return this.fields[key.toLowerCase()];\n    }\n\n    getFieldAsString(key: string): string | number| undefined {\n        const field: FieldValue | undefined = this.getField(key);\n        return normalizeFieldValue(field);\n    }\n\n    getAuthors(): Authors | undefined {\n        const field = this.fields[\"author\"];\n        if (field === undefined) return field;\n        return mustBeAuthors(field);\n    }\n}\n\n\nexport interface EntryFields {\n    [k: string]: FieldValue;\n}\n\nexport function parseEntryFields(fields: any): EntryFields {\n    const fieldz: EntryFields = {};\n    Object.keys(fields).forEach(key => {\n        switch (key) {\n            default:\n                fieldz[key] = parseFieldValue(fields[key]);\n                break;\n        }\n    });\n    return fieldz;\n}\n\n\n\n\n// export function parseComplexStringOuter(obj: any): OuterQuotedString | OuterBracedString | number {\n//     if (isString(obj)) return [obj];\n//\n//     switch (mustBeString(obj.type)) {\n//         case \"quotedstringwrapper\":\n//         case \"bracedstringwrapper\":\n//             if (!isArray(obj.data))\n//                 throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n//\n//             return obj.data.map(parseStringy);\n//         default:\n//             throw new Error(\"Unexpected complex string type: \" + obj.type);\n//     }\n// }\n\n\nexport function isBibEntry(x: any): x is BibEntry {\n    return typeof x[\"type\"] === \"string\"\n        && typeof x[\"_id\"] === \"string\"\n        && !!x[\"fields\"];\n}\n\nexport function processEntry(entry: BibEntry, strings$: { [p: string]: FieldValue }) {\n    // TODO do something with this?\n    // if (hasMandatoryFields(entry.type))\n    //     mandatoryFields[entry.type]\n    //         .map(e => findError(entry, e))\n    //         .forEach(e => {\n    //             if (!!e) console.warn(e.message);\n    //         })\n    //     ;\n\n    const processedFields: EntryFields = {};\n\n    const fields$ = entry.fields;\n\n    Object.keys(entry.fields).forEach((key: string) => {\n        const field$ = resolveStringReference({}, processedFields, strings$, fields$[key]);\n        switch (key) {\n            case \"author\":\n                processedFields[key] = new Authors(field$);\n                break;\n            case \"title\":\n                processedFields[key] = (field$);\n                break;\n            case \"incollection\":\n                // TODO cross reference\n            default:\n                processedFields[key] = field$;\n                break;\n        }\n    });\n\n\n    return new BibEntry(\n        entry.type,\n        entry._id,\n        processedFields\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/BibEntry.ts","import {mustBeArray} from \"../../util\";\nimport {parseBibEntriesAndNonEntries} from \"../BibFile\";\n\nexport class Preamble {\n    readonly type: string;\n    readonly data: any[];\n    readonly string: string;\n\n    // TODO\n    constructor(data: any[]) {\n        this.type = (\"preamble\");\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport function isPreamble(x: any): x is Preamble {\n    return x.type === \"preamble\" && !!x.data;\n}\n\n\n// function parsePreambleContents(data: any) {\n//     if (isString(data)) return data;\n//     if (isString(data.type) && data.type === \"@bib\")\n//         return \"@\" + data.string;\n//     // if (isString(data.type) && data.type === \"NON_ENTRY\")\n//     //     return ;\n//     if (isString(data.string)) return data.string;\n//     return data;\n// }\n\nexport function newPreambleNode(data: any): Preamble {\n    const flattened = parseBibEntriesAndNonEntries(mustBeArray(data.data));\n    return new Preamble(flattened);\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/BibPreamble.ts","import * as nearley from \"nearley\";\n\nimport {grammar} from \"../parser/ts-parser\";\n\nimport {isArray, mustBeString} from \"../util\";\nimport {FieldValue, isKeyVal} from \"./datatype/KeyVal\";\nimport {BibEntry, isBibEntry, parseEntryFields, processEntry} from \"./bib-entry/BibEntry\";\nimport {BibComment, CommentEntry, flattenPlainText, isBibComment} from \"./bib-entry/BibComment\";\nimport {isPreamble, Preamble, newPreambleNode} from \"./bib-entry/BibPreamble\";\nimport {newStringEntry, resolveStrings, BibStringEntry} from \"./bib-entry/BibStringEntry\";\nimport Lexer from \"../lexer/Lexer\";\n\n\nexport type NonBibComment = BibEntry | CommentEntry | BibStringEntry | Preamble;\n\n/**\n * A bibfile is a sequence of entries, with comments interspersed\n */\nexport class BibFilePresenter {\n    readonly content: (NonBibComment | BibComment)[];\n    readonly comments: BibComment[];\n\n    readonly entries_raw: BibEntry[];\n    readonly entries$: { [key: string]: BibEntry };\n\n    /**\n     * Anything declared in a @preamble command will be concatenated and put in a variable\n     named preamble$, for being used in the bibliography style and, generally, inserted at the beginning of\n     the .bbl file, just before the thebibliography environment. This is useful for defining new commands\n     used in the bibliography. Here is a small example:\n\n     \\@preamble{ \"\\makeatletter\" }\n     \\@preamble{ \"\\@ifundefined{url}{\\def\\url#1{\\texttt{#1}}}{}\" }\n     \\@preamble{ \"\\makeatother\" }\n\n     This way, you may safely use the \\url command in your entries. If it is not defined at the beginning\n     of the bibliography, the default command defined in the @preamble will be used.\n     Please note that you should never define style settings in the @preamble of a bibliography database,\n     since it would be applied to any bibliography built from this database.\n     */\n    readonly preambles_raw: Preamble[];\n    readonly preamble$: string;\n\n    readonly strings_raw: { [k: string]: FieldValue };\n    /**\n     * `strings`, but with all references resolved\n     */\n    readonly strings$: { [k: string]: FieldValue };\n\n\n    constructor(content: (NonBibComment | BibComment)[]) {\n        this.content = content;\n        this.comments = content.filter(isBibComment).map(c => {\n            if (isBibComment(c))return c; else throw new Error();\n        });\n\n\n\n        this.preambles_raw = content.filter(c => isPreamble(c)).map(c => {\n            if (isPreamble(c)) return c; else throw new Error();\n        });\n        this.preamble$ = this.preambles_raw.map(p => p.toString()).join(\"\\n\");\n\n        const strings: { [k: string]: FieldValue } = {};\n        this.content.forEach(entry => {\n                if (isKeyVal(entry)) {\n                    if (!!strings[entry.key])\n                        throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\n                    strings[entry.key] = entry.value;\n                }\n            }\n        );\n\n        this.strings_raw = strings;\n        this.strings$ = resolveStrings(strings);\n\n        this.entries_raw = content.filter(c => isBibEntry(c)).map(c => {\n            if (isBibEntry(c)) return c;\n            else throw new Error();\n        });\n\n        const entryMap: { [k: string]: BibEntry } = {};\n        this.entries_raw.forEach((entry: BibEntry) => {\n            const key = entry._id.toLowerCase();\n            /**\n             * BibTEX will complain if two entries have the same internal key, even if they arent capitalized in the same\n             * way. For instance, you cannot have two entries named Example and example.\n             * In the same way, if you cite both example and Example, BibTEX will complain. Indeed, it would\n             * have to include the same entry twice, which probably is not what you want\n             */\n            if (!!entryMap[key]) throw new Error(\"Entry with id \" + key + \" was defined more than once\");\n            entryMap[key] = processEntry(entry, this.strings$);\n        });\n        this.entries$ = entryMap;\n    }\n\n    getEntry(id: string): BibEntry | undefined {\n        return this.entries$[id.toLowerCase()];\n    }\n}\n\nfunction parseNonEntry(nonEntry: any): BibComment {\n    if (!isArray(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\") throw new Error();\n    return new BibComment(flattenPlainText(nonEntry.data));\n}\n\n\nfunction parseEntry(entry: any): NonBibComment {\n    switch (typeof entry) {\n        case \"object\":\n            const data = entry.data;\n            if (typeof data[\"@type\"] === \"string\") {\n                return new BibEntry(\n                    data[\"@type\"],\n                    data._id,\n                    parseEntryFields(data.fields)\n                );\n            }\n\n            const type = mustBeString(data.type);\n            switch (type) {\n                case \"string\":\n                    return newStringEntry(data);\n                case \"preamble\":\n                    return newPreambleNode(data);\n                // case \"bracedstringwrapper\":\n                //     return new BracedString(parseComplexStringOuter(data));\n                // case \"quotedstringwrapper\":\n                //     return new QuotedString(parseComplexStringOuter(data));\n                // case \"braced\":\n                // case \"quotedstring\":\n                default:\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\n            }\n        default:\n            throw new Error(\"Expected object as data for entry\");\n    }\n}\n\nexport const parseBibEntriesAndNonEntries = function (parse: any): (BibComment | NonBibComment)[] {\n    return parse.map((entity: any) => {\n        switch (entity.type) {\n            case \"NON_ENTRY\":\n                return (parseNonEntry(entity));\n            case \"ENTRY\":\n                return (parseEntry(entity));\n            default:\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\n        }\n    });\n};\n\nexport function parseBibFile(input: string): BibFilePresenter {\n    const p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);\n    p.feed(new Lexer(input).readTokens());\n    const res = p.results;\n    const parse = res[0];\n\n    return new BibFilePresenter(parseBibEntriesAndNonEntries(parse));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/BibFile.ts","export type Token = TypedToken | string | number;\n\nexport interface TypedToken {\n    type: string;\n    string?: string;\n}\n\nexport function newToken(type: string, string: string): TypedToken {\n    return {\n        type,\n        string\n    };\n}\n\n\nexport const specialChars = {\n    \"@\": true,\n    \"(\": true,\n    \")\": true,\n    \"{\": true,\n    \"}\": true,\n    \"#\": true,\n    \"=\": true,\n    \",\": true,\n    \"\\\\\": true,\n    \"\\\"\": true,\n};\n\nexport type SpecialChar = keyof typeof specialChars;\n\nexport function isSpecialChar(c: string): c is SpecialChar {\n    return specialChars.hasOwnProperty(c);\n}\n\n\nexport const escapableChars = {\n    \"\\\\\": true,\n    \"@\": true,\n    \"{\": true,\n    \"}\": true\n};\n\nexport type EscapableChar = keyof typeof escapableChars;\n\nexport function isEscapableChar(c: string): c is EscapableChar {\n    return escapableChars.hasOwnProperty(c);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/Token.ts","import {TypedToken} from \"./Token\";\n\nexport const WS = \"ws\";\n\nexport function newWhitespace(string: string): WhitespaceToken {\n    return {\n        type: \"ws\",\n        string\n    };\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function isWhitespace(token: any): token is WhitespaceToken {\n    return typeof token.string === \"string\" && token.type === WS;\n}\n\n\nexport interface WhitespaceToken extends TypedToken {\n    type: \"ws\";\n}\n\nexport const singleWhitespaces = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\r\": true,\n    \"\\n\": true\n};\n\nexport type SingleWhitespace = keyof typeof singleWhitespaces;\n\nexport function isSingleWhiteSpaceCharacter(c: string): c is SingleWhitespace {\n    return singleWhitespaces.hasOwnProperty(c);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/WhitespaceToken.ts","// export const NUMBER = \"number\";\n\nimport {TypedToken} from \"./Token\";\n\nexport function newNumber(string: string): NumberToken {\n    return {\n        type: \"number\",\n        string\n    };\n}\n\nexport interface NumberToken extends TypedToken {\n    type: \"number\";\n}\n\nexport const numericChars = {\n    \"0\": true,\n    \"1\": true,\n    \"2\": true,\n    \"3\": true,\n    \"4\": true,\n    \"5\": true,\n    \"6\": true,\n    \"7\": true,\n    \"8\": true,\n    \"9\": true\n};\n\nexport type NumericChar = keyof typeof numericChars;\n\nexport function isNum(c: string): c is NumericChar {\n    return numericChars.hasOwnProperty(c);\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/NumericToken.ts","export * from \"./bibfile/bib-entry/bibliographic-entity/Author\";\nexport * from \"./bibfile/bib-entry/bibliographic-entity/Authors\";\nexport * from \"./bibfile/bib-entry/bibliographic-entity/mandatory-and-optional-fields\";\nexport * from \"./bibfile/bib-entry/BibComment\";\nexport * from \"./bibfile/bib-entry/BibEntry\";\nexport * from \"./bibfile/bib-entry/BibPreamble\";\nexport * from \"./bibfile/bib-entry/BibStringEntry\";\nexport * from \"./bibfile/datatype/string/bib-string-utils\";\nexport * from \"./bibfile/datatype/string/BibStringComponent\";\nexport * from \"./bibfile/datatype/string/BibStringData\";\nexport * from \"./bibfile/datatype/string/BracedString\";\nexport * from \"./bibfile/datatype/string/QuotedString\";\nexport * from \"./bibfile/datatype/string/StringRef\";\nexport * from \"./bibfile/datatype/KeyVal\";\nexport * from \"./bibfile/BibFile\";\nexport * from \"./util\";\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/index.ts","import {isArray, isString} from \"../../../util\";\nimport {BibEntry} from \"../BibEntry\";\n\n/**\n * From Taming the BeaST: http://ctan.cs.uu.nl/info/bibtex/tamethebeast/ttb_en.pdf\n *\n <dl>\n\n <dt>address</dt>\n <dd>Generally the city or complete address of the publisher.\n </dd>\n\n <dt>author</dt>\n <dd>For author names. The input format is quite special, since BibTEX has to be\n able to distinguish between the first and last names. Section 11 and 18 are\n completely dedicated to this topic.\n </dd>\n\n <dt>booktitle</dt>\n <dd>For the title of a book one part of which is cited.\n </dd>\n\n <dt>chapter</dt>\n <dd>The number of the chapter (or any part) of a book being cited. If not a chapter,\n the type field might be used for precising the type of sectioning.\n </dd>\n\n <dt>crossref</dt>\n <dd>This one is quite peculiar. Its used to cross-reference within the bibliography.\n For instance, you might cite a document, and a part of it. In that case, the\n second one can reference the first one, or at least inherit some of its fields from\n the first one. This deserves some more comments, see section 12.\n </dd>\n\n <dt>edition</dt>\n <dd>The edition number. Or in fact its ordinal, for instance edition = \"First\".\n This might raise problems when trying to export a bibliography into another\n language.\n </dd>\n\n <dt>editor</dt>\n <dd>The name of the editor(s) of the entry. The format is the same as for authors.\n </dd>\n\n <dt>howpublished</dt>\n <dd>Only used in rare cases where the document being cited is not a classical type\n such as a @book, an @article or an @inproceedings publication.\n </dd>\n\n <dt>institution</dt>\n <dd>For a technical report, the name of the institution that published it.\n </dd>\n\n <dt>journal</dt>\n <dd>The name of the journal in which the cited article has been published.\n key Used for defining the label, in case it cannot be computed by BibTEX. It does\n not force the label, but defines the label when BibTEX needs one but cant\n compute it.\n </dd>\n\n <dt>month</dt>\n <dd>Well... The month during which the document has been published. This also\n raises the problem of the translation of the bibliography: Its better having\n a numerical value, or an abbreviation, instead of the complete name of the\n month. Having the number would also allow BibTEX to sort the entries more\n precisely (even though, as far as I know, no bibliography style does this at the\n present time).\n </dd>\n\n <dt>note</dt>\n <dd>For any additional data you would want to add. Since classical styles were\n written in 1985, they dont have a url field, and note is often used for this\n purpose, together with the url.sty package.</dd>\n\n <dt>number</dt>\n <dd>A number... Not whichever, but the number of a report. For volume numbers,\n a special volume field exists.\n organization The organizing institution of a conference.\n </dd>\n\n <dt>pages</dt>\n <dd>The relevant pages of the document. Useful for the reader when you cite a huge\n book; Note that such a precision could be added through the optional argument\n of \\cite (see page 6), in which case it would appear in the document but not\n in the bibliography.\n </dd>\n\n <dt>publisher</dt>\n <dd>The institution that published the document.\n </dd>\n\n <dt>school</dt>\n <dd>For theses, the name of the school the thesis has been prepared in.\n </dd>\n\n <dt>series</dt>\n <dd>The name of a collection of series or books.\n </dd>\n\n <dt>title</dt>\n <dd>The title of the document being cited. There are some rules to be observed\n when entering this field, see section 10.\n </dd>\n\n <dt>type</dt>\n <dd>The type. Which type? It depends... The type of publication, if needed. For\n </dd>\n\n <dt>thesi</dt>\n <dd>s, for instance, in order to distinguish between a masters thesis and a PhD.\n Or the type of section being cited (see chapter above).\n </dd>\n\n <dt>volume</dt>\n <dd>The volume number in a series or collection of books.\n </dd>\n\n <dt>year</dt>\n <dd>The publication year.</dd>\n\n </dl>\n **/\nexport const address = \"address\";\nexport const author = \"author\";\nexport const booktitle = \"booktitle\";\nexport const chapter = \"chapter\";\nexport const edition = \"edition\";\nexport const editor = \"editor\";\nexport const howpublished = \"howpublished\";\nexport const institution = \"institution\";\nexport const journal = \"journal\";\nexport const month = \"month\";\nexport const note = \"note\";\nexport const number = \"number\";\nexport const organization = \"organization\";\nexport const pages = \"pages\";\nexport const publisher = \"publisher\";\nexport const school = \"school\";\nexport const series = \"series\";\nexport const title = \"title\";\nexport const type = \"type\";\nexport const volume = \"volume\";\nexport const year = \"year\";\n\nexport type KnownField = \"address\" |\n    \"author\" |\n    \"booktitle\" |\n    \"chapter\" |\n    \"edition\" |\n    \"editor\" |\n    \"howpublished\" |\n    \"institution\" |\n    \"journal\" |\n    \"month\" |\n    \"note\" |\n    \"number\" |\n    \"organization\" |\n    \"pages\" |\n    \"publisher\" |\n    \"school\" |\n    \"series\" |\n    \"title\" |\n    \"type\" |\n    \"volume\" |\n    \"year\";\n\nexport type MandatoryFields = KnownField | KnownField[];\nexport type OptionalFields = KnownField | KnownField[];\n\nexport const optionalFields: { [k: string]: (KnownField | KnownField[])[] } = {\n    \"book\": [[\"volume\", \"number\"], \"series\", \"address\", \"edition\", \"month\", \"note\"],\n    \"booklet\": [\"author\", \"howpublished\", \"address\", \"address\", \"month\", \"year\", \"note\"],\n    \"conference\": [\"editor\", [\"volume\", \"number\"], \"series\", \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inproceedings\": [\"editor\", [\"volume\", \"number\"], series, \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inbook\": [\"volume\", \"number\", \"series\", \"type\", \"address\", \"edition\", \"month\", \"note\"],\n    \"incollection\": [\"editor\", [\"volume\", \"number\"], \"series\", \"type\", \"chapter\", \"pages\", \"address\", \"edition\", \"month\", \"note\"],\n    \"manual\": [\"author\", \"organization\", \"year\", \"address\", \"edition\", \"month\", \"note\"],\n    \"mastersthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"misc\": [],\n    \"phdthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"proceedings\": [\"editor\", [\"volume\", \"number\"], \"series\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"techreport\": [\"type\", \"address\", \"number\", \"month\", \"note\"],\n    \"unpublished\": [\"month\", \"year\"]\n};\n\nexport const mandatoryFields: { [k: string]: (KnownField | KnownField[])[] } = {\n    \"article\": [\"author\", \"title\", \"year\", \"journal\"],\n    \"book\": [[\"author\", \"editor\"], \"title\", \"publisher\", \"year\"],\n    \"booklet\": [\"title\"],\n    \"conference\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inproceedings\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inbook\": [[\"author\", \"editor\"], \"title\", [\"chapter\", \"pages\"]],\n    \"incollection\": [\"author\", \"title\", \"booktitle\", \"publisher\", \"year\"],\n    \"manual\": [\"title\"],\n    \"mastersthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"misc\": [[\"author\", \"title\", \"howpublished\", \"year\", \"month\", \"note\"]],\n    \"phdthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"proceedings\": [\"year\", \"title\"],\n    \"techreport\": [\"author\", \"title\", \"institution\", \"year\"],\n    \"unpublished\": [\"author\", \"title\", \"note\"]\n};\n\nexport function hasOptionalFields(s: string): s is Extract<(keyof typeof optionalFields), string> {\n    return optionalFields.hasOwnProperty(s);\n}\n\nexport function hasMandatoryFields(s: string): s is Extract<(keyof typeof mandatoryFields), string> {\n    return mandatoryFields.hasOwnProperty(s);\n}\n\nexport function getMandatoryFields(s: string): MandatoryFields[] {\n    if (hasMandatoryFields(s)) {\n        return mandatoryFields[s];\n    } else {\n        return [];\n    }\n}\n\nexport function getOptionalFields(s: string): OptionalFields[] {\n    if (hasOptionalFields(s)) {\n        return optionalFields[s];\n    } else {\n        return [];\n    }\n}\n\nexport const findError = (entry: BibEntry, field: MandatoryFields): (Error | undefined) => {\n    const fields = entry.fields;\n    if (isString(field)) {\n        if (!fields[field])\n            return new Error(\"Warning: expected \" + entry.type + \" with id \" + entry._id\n                + \" to have the field: \" + field);\n    } else if (isArray(field)) {\n        const hasAllFields: boolean = field.reduce(\n            (acc: boolean, fieldName: KnownField): boolean => {\n                if (isString(fieldName)) {\n                    return (acc && fields.hasOwnProperty(fieldName));\n                }\n                else\n                    throw new Error();\n            }, true\n        );\n        if (!hasAllFields) {\n            // not one of a list of options\n            return new Error(\"Expected \" + entry.type + \" with id \" + entry._id\n                + \" to have one of the following fields: \" + field);\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/bibfile/bib-entry/bibliographic-entity/mandatory-and-optional-fields.ts","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    var token;\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/nearley/lib/nearley.js\n// module id = 19\n// module chunks = 0","function id(x) {\n    return x[0];\n}\n\nconst isNumber = function (x) {\n    return x.constructor === Number || (typeof x === \"object\" && x.type === \"number\");\n};\nconst tok_id = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"id\";\n    }\n};\nconst entry_type_bib = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@bib\";\n    }\n};\nconst entry_type_string = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@string\";\n    }\n};\nconst entry_type_preamble = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@preamble\";\n    }\n};\nconst entry_type_comment = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@comment\";\n    }\n};\nconst ws: any = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"ws\";\n    }\n};\nconst num: any = {test: isNumber};\nconst pound: any = {literal: \"#\"};\nconst eq: any = {literal: \"=\"};\nconst esc: any = {literal: \"\\\\\"};\nconst paren_l = {literal: \"(\"};\nconst paren_r = {literal: \")\"};\nconst brace_l = {literal: \"{\"};\nconst brace_r = {literal: \"}\"};\nconst quote_dbl = {literal: \"\\\"\"};\nconst comma: any = {literal: \",\"};\n\n\nfunction addToObj(obj, keyval) {\n    if (keyval.type !== \"keyval\") throw new Error(\"Expected a keyval object\");\n    const key = keyval.key.toLowerCase();\n    if (obj.fields[key]) {\n        // TODO error?\n        // console.log(\"WARNING: field '\" + key + \"' was already defined on \" + obj[\"@type\"] + \" object with id '\" + obj._id + \"'. Ignoring this value.\");\n        return;\n    } else {\n        obj.fields[key] = keyval.value;\n        return obj;\n    }\n}\n\nfunction joinTokens(arr) {\n    const strs: any = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (typeof arr[i] === \"object\") {\n            if (!arr[i].string) throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\n            strs.push(arr[i].string);\n        } else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\n            strs.push(arr[i]);\n        } else throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\n    }\n    return strs.join(\"\");\n}\n\nexport const grammar: any = {\n    Lexer: undefined,\n    ParserRules: [\n        {\"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2\", \"symbols\": []},\n        {\"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"]},\n        {\n            \"name\": \"main$ebnf$2\",\n            \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"main\",\n            \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const topLevelObjects: any = [];\n                // console.log(JSON.stringify(data));\n                if (data[0])\n                    topLevelObjects.push({type: \"NON_ENTRY\", data: data[0]});\n\n                for (let i = 0; i < data[1].length; i++) {\n\n                    topLevelObjects.push({type: \"ENTRY\", data: data[1][i][0]});\n\n                    if (data[1][i][1])\n                        topLevelObjects.push({type: \"NON_ENTRY\", data: data[1][i][1]});\n                }\n                return topLevelObjects;\n            }\n        },\n        {\"name\": \"_$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n        },\n        {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"entry_decl\",\n            \"symbols\": [\"entry_decl$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"]},\n        {\n            \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function (data) {\n            return data[0][0];\n        }\n        },\n        {\n            \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function (data) {\n            return data[0];\n        }\n        },\n        {\"name\": \"comment_liberal$ebnf$1\", \"symbols\": []},\n        {\"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./]},\n        {\n            \"name\": \"comment_liberal$ebnf$1\",\n            \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"comment_liberal\",\n            \"symbols\": [\"comment_liberal$ebnf$1\"],\n            \"postprocess\": function (data) {\n                const toeknz: any = [];\n                for (let tk = 0; tk < data[0].length; tk++)\n                    toeknz.push(data[0][tk][0]);\n                return toeknz;\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_comment\",\n            \"symbols\": [\"entry_body_comment$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_string\",\n            \"symbols\": [\"entry_body_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_bib\",\n            \"symbols\": [\"entry_body_bib$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"bib_content$ebnf$1\", \"symbols\": []},\n        {\"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"]},\n        {\n            \"name\": \"bib_content$ebnf$1\",\n            \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma]},\n        {\"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id},\n        {\n            \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\n            \"name\": \"bib_content\",\n            \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[0],\n                    fields: []\n                };\n                const keyvals = data[4];\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    obj.fields.push(keyvals[kv][0]);\n                }\n                obj.fields.push(data[5]);\n                return obj;\n            }\n        },\n        {\n            \"name\": \"bib_entry\",\n            \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[2]._id\n                };\n                obj[\"@type\"] = data[0].string;\n                obj.fields = {};\n\n                const keyvals = data[2].fields;\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    addToObj(obj, keyvals[kv]);\n                }\n                return obj;\n            }\n        },\n        {\n            \"name\": \"string_entry\",\n            \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"string\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"preamble_entry\",\n            \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"preamble\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"comment_entry\",\n            \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"comment\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"keyval\",\n            \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"keyval\", key: data[0], value: data[4]};\n            }\n        },\n        {\"name\": \"braced_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"]},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"braced_string$ebnf$1\",\n            \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"braced_string\",\n            \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\n            \"postprocess\": function (data) {\n                const tkz: any = [];\n                for (const i in data[1]) tkz.push(data[1][i][0]);\n                return {type: \"braced\", data: tkz};\n            }\n\n        },\n        {\"name\": \"quoted_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"quoted_string$ebnf$1\",\n            \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"quoted_string\",\n            \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\n            \"postprocess\": function (data) {\n                const tks: any = [];\n                for (const i in data[1]) tks.push(data[1][i][0]);\n                return {type: \"quotedstring\", data: tks};\n            }\n        },\n        {\"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"]},\n        {\"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"]},\n        {\n            \"name\": \"key_string$ebnf$1\",\n            \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function (data) {\n            return joinTokens(data[0]).toLowerCase();\n        }\n        },\n        {\"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\n            \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\n        },\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1\",\n            \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"value_string$subexpression$1\",\n            \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\n        },\n        {\"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"value_string\",\n            \"symbols\": [\"value_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"DATA\",JSON.stringify(data));\n                const match = data[0];\n                if (match.length === 2) {\n                    // quoted string\n                    const tokenz: any = [];\n                    tokenz.push(match[0]);\n                    for (let i = 0; i < match[1].length; i++) tokenz.push(match[1][i][3]);\n                    return {type: \"quotedstringwrapper\", data: tokenz};\n                } else if (match[0].type === \"braced\")\n                    return {type: \"bracedstringwrapper\", data: match[0].data};\n                // else if(isNumber(match[0]) return [match[0]];\n                else throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\n            }\n        },\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num]},\n        {\n            \"name\": \"quoted_string_or_ref\",\n            \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(data);\n                if (data[0][0].type === \"quotedstring\") return data[0][0];\n                else {\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"string_ref$subexpression$1$ebnf$1\",\n            \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"string_ref$subexpression$1\",\n            \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\n        },\n        {\n            \"name\": \"string_ref\",\n            \"symbols\": [\"string_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                const str = data[0][0] + joinTokens(data[0][1]);\n                return {stringref: str};\n            }\n        },\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken\",\n            \"symbols\": [\"stringreftoken$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken_n_num\",\n            \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_brace\",\n            \"symbols\": [\"non_brace$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_bracket\",\n            \"symbols\": [\"non_bracket$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\n            \"name\": \"non_entry$ebnf$1\",\n            \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function (data) {\n            // console.log(\"non_entry\",data);\n            const tokens: any = [];\n            for (let Ti = 0; Ti < data[0].length; Ti++) tokens.push(data[0][Ti][0]);\n            return tokens;\n        }\n        },\n        {\n            \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function () {\n            return \"\\\\\";\n        }\n        },\n        {\n            \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function (data) {\n            return {type: \"escapedEntry\", data: data[1]};\n        }\n        },\n        {\n            \"name\": \"escaped_non_esc_outside_entry\",\n            \"symbols\": [esc, \"non_esc_outside_entry\"],\n            \"postprocess\": function (data) {\n                return data; // [\"\\\\\", data[1]];\n            }\n        },\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma]},\n        {\n            \"name\": \"non_esc_outside_entry\",\n            \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"ooutside_entry\",data[0][0]);\n                return data[0][0];\n            }\n        }\n    ]\n    , ParserStart: \"main\"\n};\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/parser/ts-parser.ts","import {TypedToken, isSpecialChar, newToken, Token} from \"./Token\";\nimport {isSingleWhiteSpaceCharacter, WhitespaceToken, SingleWhitespace, newWhitespace} from \"./WhitespaceToken\";\nimport {isNum, NumericChar, NumberToken, newNumber} from \"./NumericToken\";\nimport {IdToken, isIdChar, newIdToken} from \"./IdToken\";\nimport {isBibType, bibTypes} from \"./BibBlockTypes\";\n\nexport default class Lexer {\n    private str: string;\n    private len: number;\n    private pos: number;\n\n    constructor(string: string) {\n        this.str = string;\n        this.len = string.length;\n        this.pos = 0;\n    }\n\n    getStringUntilNonEscapedChar(terminalRegex: RegExp | string): string {\n        // if (typeof terminalRegex === 'string') {\n        // }\n        const chars: string[] = [];\n        for (let i = this.pos; i < this.len + 1; i++) {\n            this.pos = i;\n            if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\n                i++;\n                this.pos = i;\n            } else if (this.str.charAt(i).match(terminalRegex)) {\n                break;\n            }\n            chars.push(this.str.charAt(i));\n        }\n        return chars.join(\"\");\n    }\n    readTokens(): Token[] {\n        const tokens: Token[] = [];\n        let nextToken;\n        while (nextToken = this.readNextToken())\n            tokens.push(nextToken);\n        return tokens;\n    }\n\n    readNextToken(): Token | undefined {\n        if (this.pos >= this.str.length)\n            return undefined;\n\n        const currentChar: string = this.str.charAt(this.pos);\n\n        if (isSingleWhiteSpaceCharacter(currentChar))\n            return this.eatWhiteSpace();\n        else if (isSpecialChar(currentChar)) {\n            return this.eatSpecialChars(currentChar);\n        } else if (isNum(currentChar)) {\n            return this.eatNumericString(currentChar);\n        } else {\n            return this.eatIdString();\n        }\n    }\n\n    // NOTE: not needed? delete?\n    // isEscapeChar(i: number): boolean {\n    //     if (this.str.charAt(i) == '\\\\') {\n    //         // Might be an escaped character\n    //         const nextChar = this.str.charAt(i + 1);\n    //\n    //         // We've escaped a special character\n    //         return isEscapableChar(nextChar);\n    //     } else return false;\n    // }\n\n    private eatIdString(): IdToken {\n        // id\n        const chars: string[] = [];\n        const pos2 = this.pos;\n        for (let i = pos2; i < this.len + 1; i++) {\n            this.pos = i;\n            // console.log(this.pos, i);\n            // console.log(this.pos, this.str.charAt(i));\n            const charAtI = this.str.charAt(i);\n            if (!isIdChar(charAtI)) {\n                break;\n                // else if (charAtI == '\\\\' && (this.str.charAt(i + 1) == '\\\\' || isSpecialChar(this.str.charAt(i + 1)))) {\n                //  i++;\n                //  this.pos = i;\n                //  chars.push(this.str.charAt(i));\n            } else {\n                chars.push(charAtI);\n            }\n        }\n\n        return newIdToken(chars.join(\"\").trim());\n    }\n\n    private eatNumericString(startAt: NumericChar): number | NumberToken {\n        const nums: NumericChar[] = [startAt];\n\n        const nextPos = this.pos + 1;\n        for (let newPos = nextPos; newPos < this.len + 1; newPos++) {\n            this.pos = newPos;\n\n            const newChar = this.str.charAt(newPos);\n            if (isNum(newChar))\n                nums.push(newChar);\n            else\n                break;\n        }\n\n        const numericString: string = nums.join(\"\");\n\n        if (nums[0] === \"0\")  // If it starts with 0, return as a string\n            return newNumber(numericString);\n        else {\n            const number = Number.parseInt(numericString);\n            return Number.isFinite(number) ? number : newNumber(numericString);\n        }\n    }\n\n    private eatSpecialChars(startAt: string): string | TypedToken {\n        this.pos++;\n        if (startAt === \"@\") {\n            const type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\n            if (isBibType(type))\n                return newToken(bibTypes[type], type);\n            else\n                return newToken(\"@bib\", type);\n        }\n        return startAt;\n    }\n\n    private eatWhiteSpace(): WhitespaceToken {\n        const chars: SingleWhitespace[] = [];\n        while (this.pos < this.len + 1) {\n            const c = this.str.charAt(this.pos);\n            // ignore whitespaces\n            if (isSingleWhiteSpaceCharacter(c)) {\n                chars.push(c);\n                this.pos++;\n            } else break;\n        }\n        return newWhitespace(chars.join(\"\"));\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/Lexer.ts","import {TypedToken, SpecialChar, isSpecialChar} from \"./Token\";\n\nimport {SingleWhitespace, isSingleWhiteSpaceCharacter} from \"./WhitespaceToken\";\nimport {isNum, NumericChar} from \"./NumericToken\";\n\nexport interface IdToken extends TypedToken {\n    type: \"id\";\n    string: string;\n}\n\nexport function newIdToken(string: string): IdToken {\n    return {\n        type: \"id\",\n        string\n    };\n}\n\nexport function isIdToken(string: any): string is IdToken {\n    return string.type === \"id\" && typeof string.string === \"string\";\n}\n\nexport function isIdChar(c: string): c is IdChar {\n    return !(isSpecialChar(c) || isNum(c) || isSingleWhiteSpaceCharacter(c));\n}\n\nexport type IdChar = SpecialChar | NumericChar | SingleWhitespace;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/IdToken.ts","export const bibTypes = {\n    string: \"@string\",\n    preamble: \"@preamble\",\n    comment: \"@comment\",\n    bib: \"@bib\"\n};\n\nexport type BibType = keyof typeof bibTypes;\n\nexport const isBibType = function (c: string): c is BibType {\n    return bibTypes.hasOwnProperty(c);\n};\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/lexer/BibBlockTypes.ts"],"sourceRoot":""}